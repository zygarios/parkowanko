{"version":3,"sources":["node_modules/@angular/forms/fesm2022/_validation_errors-chunk.mjs","node_modules/@angular/forms/fesm2022/signals.mjs","src/app/_others/_helpers/validation-messages.ts"],"sourcesContent":["/**\n * @license Angular v21.2.0-rc.0\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { untracked, ÉµRuntimeError as _RuntimeError, computed, runInInjectionContext, Injector, linkedSignal, signal, APP_ID, effect, inject } from '@angular/core';\nimport { AbstractControl, FormGroup, FormArray } from '@angular/forms';\nimport { SIGNAL } from '@angular/core/primitives/signals';\nlet boundPathDepth = 0;\nfunction getBoundPathDepth() {\n  return boundPathDepth;\n}\nfunction setBoundPathDepthForResolution(fn, depth) {\n  return (...args) => {\n    try {\n      boundPathDepth = depth;\n      return fn(...args);\n    } finally {\n      boundPathDepth = 0;\n    }\n  };\n}\nfunction shortCircuitFalse(value) {\n  return !value;\n}\nfunction shortCircuitTrue(value) {\n  return value;\n}\nfunction getInjectorFromOptions(options) {\n  if (options.kind === 'root') {\n    return options.fieldManager.injector;\n  }\n  return options.parent.structure.root.structure.injector;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isObject(value) {\n  return (typeof value === 'object' || typeof value === 'function') && value != null;\n}\nconst DYNAMIC = /*#__PURE__*/Symbol();\nconst IGNORED = /*#__PURE__*/Symbol();\nclass AbstractLogic {\n  predicates;\n  fns = [];\n  constructor(predicates) {\n    this.predicates = predicates;\n  }\n  push(logicFn) {\n    this.fns.push(wrapWithPredicates(this.predicates, logicFn));\n  }\n  mergeIn(other) {\n    const fns = this.predicates ? other.fns.map(fn => wrapWithPredicates(this.predicates, fn)) : other.fns;\n    this.fns.push(...fns);\n  }\n}\nclass BooleanOrLogic extends AbstractLogic {\n  get defaultValue() {\n    return false;\n  }\n  compute(arg) {\n    return this.fns.some(f => {\n      const result = f(arg);\n      return result && result !== IGNORED;\n    });\n  }\n}\nclass ArrayMergeIgnoreLogic extends AbstractLogic {\n  ignore;\n  static ignoreNull(predicates) {\n    return new ArrayMergeIgnoreLogic(predicates, e => e === null);\n  }\n  constructor(predicates, ignore) {\n    super(predicates);\n    this.ignore = ignore;\n  }\n  get defaultValue() {\n    return [];\n  }\n  compute(arg) {\n    return this.fns.reduce((prev, f) => {\n      const value = f(arg);\n      if (value === undefined || value === IGNORED) {\n        return prev;\n      } else if (isArray(value)) {\n        return [...prev, ...(this.ignore ? value.filter(e => !this.ignore(e)) : value)];\n      } else {\n        if (this.ignore && this.ignore(value)) {\n          return prev;\n        }\n        return [...prev, value];\n      }\n    }, []);\n  }\n}\nclass ArrayMergeLogic extends ArrayMergeIgnoreLogic {\n  constructor(predicates) {\n    super(predicates, undefined);\n  }\n}\nclass MetadataMergeLogic extends AbstractLogic {\n  key;\n  get defaultValue() {\n    return this.key.reducer.getInitial();\n  }\n  constructor(predicates, key) {\n    super(predicates);\n    this.key = key;\n  }\n  compute(ctx) {\n    if (this.fns.length === 0) {\n      return this.key.reducer.getInitial();\n    }\n    let acc = this.key.reducer.getInitial();\n    for (let i = 0; i < this.fns.length; i++) {\n      const item = this.fns[i](ctx);\n      if (item !== IGNORED) {\n        acc = this.key.reducer.reduce(acc, item);\n      }\n    }\n    return acc;\n  }\n}\nfunction wrapWithPredicates(predicates, logicFn) {\n  if (predicates.length === 0) {\n    return logicFn;\n  }\n  return arg => {\n    for (const predicate of predicates) {\n      let predicateField = arg.stateOf(predicate.path);\n      const depthDiff = untracked(predicateField.structure.pathKeys).length - predicate.depth;\n      for (let i = 0; i < depthDiff; i++) {\n        predicateField = predicateField.structure.parent;\n      }\n      if (!predicate.fn(predicateField.context)) {\n        return IGNORED;\n      }\n    }\n    return logicFn(arg);\n  };\n}\nclass LogicContainer {\n  predicates;\n  hidden;\n  disabledReasons;\n  readonly;\n  syncErrors;\n  syncTreeErrors;\n  asyncErrors;\n  metadata = /*#__PURE__*/new Map();\n  constructor(predicates) {\n    this.predicates = predicates;\n    this.hidden = new BooleanOrLogic(predicates);\n    this.disabledReasons = new ArrayMergeLogic(predicates);\n    this.readonly = new BooleanOrLogic(predicates);\n    this.syncErrors = ArrayMergeIgnoreLogic.ignoreNull(predicates);\n    this.syncTreeErrors = ArrayMergeIgnoreLogic.ignoreNull(predicates);\n    this.asyncErrors = ArrayMergeIgnoreLogic.ignoreNull(predicates);\n  }\n  hasMetadata(key) {\n    return this.metadata.has(key);\n  }\n  getMetadataKeys() {\n    return this.metadata.keys();\n  }\n  getMetadata(key) {\n    if (!this.metadata.has(key)) {\n      this.metadata.set(key, new MetadataMergeLogic(this.predicates, key));\n    }\n    return this.metadata.get(key);\n  }\n  mergeIn(other) {\n    this.hidden.mergeIn(other.hidden);\n    this.disabledReasons.mergeIn(other.disabledReasons);\n    this.readonly.mergeIn(other.readonly);\n    this.syncErrors.mergeIn(other.syncErrors);\n    this.syncTreeErrors.mergeIn(other.syncTreeErrors);\n    this.asyncErrors.mergeIn(other.asyncErrors);\n    for (const key of other.getMetadataKeys()) {\n      const metadataLogic = other.metadata.get(key);\n      this.getMetadata(key).mergeIn(metadataLogic);\n    }\n  }\n}\nclass AbstractLogicNodeBuilder {\n  depth;\n  constructor(depth) {\n    this.depth = depth;\n  }\n  build() {\n    return new LeafLogicNode(this, [], 0);\n  }\n}\nclass LogicNodeBuilder extends AbstractLogicNodeBuilder {\n  constructor(depth) {\n    super(depth);\n  }\n  current;\n  all = [];\n  addHiddenRule(logic) {\n    this.getCurrent().addHiddenRule(logic);\n  }\n  addDisabledReasonRule(logic) {\n    this.getCurrent().addDisabledReasonRule(logic);\n  }\n  addReadonlyRule(logic) {\n    this.getCurrent().addReadonlyRule(logic);\n  }\n  addSyncErrorRule(logic) {\n    this.getCurrent().addSyncErrorRule(logic);\n  }\n  addSyncTreeErrorRule(logic) {\n    this.getCurrent().addSyncTreeErrorRule(logic);\n  }\n  addAsyncErrorRule(logic) {\n    this.getCurrent().addAsyncErrorRule(logic);\n  }\n  addMetadataRule(key, logic) {\n    this.getCurrent().addMetadataRule(key, logic);\n  }\n  getChild(key) {\n    if (key === DYNAMIC) {\n      const children = this.getCurrent().children;\n      if (children.size > (children.has(DYNAMIC) ? 1 : 0)) {\n        this.current = undefined;\n      }\n    }\n    return this.getCurrent().getChild(key);\n  }\n  hasLogic(builder) {\n    if (this === builder) {\n      return true;\n    }\n    return this.all.some(({\n      builder: subBuilder\n    }) => subBuilder.hasLogic(builder));\n  }\n  mergeIn(other, predicate) {\n    if (predicate) {\n      this.all.push({\n        builder: other,\n        predicate: {\n          fn: setBoundPathDepthForResolution(predicate.fn, this.depth),\n          path: predicate.path\n        }\n      });\n    } else {\n      this.all.push({\n        builder: other\n      });\n    }\n    this.current = undefined;\n  }\n  getCurrent() {\n    if (this.current === undefined) {\n      this.current = new NonMergeableLogicNodeBuilder(this.depth);\n      this.all.push({\n        builder: this.current\n      });\n    }\n    return this.current;\n  }\n  static newRoot() {\n    return new LogicNodeBuilder(0);\n  }\n}\nclass NonMergeableLogicNodeBuilder extends AbstractLogicNodeBuilder {\n  logic = /*#__PURE__*/new LogicContainer([]);\n  children = /*#__PURE__*/new Map();\n  constructor(depth) {\n    super(depth);\n  }\n  addHiddenRule(logic) {\n    this.logic.hidden.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addDisabledReasonRule(logic) {\n    this.logic.disabledReasons.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addReadonlyRule(logic) {\n    this.logic.readonly.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addSyncErrorRule(logic) {\n    this.logic.syncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addSyncTreeErrorRule(logic) {\n    this.logic.syncTreeErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addAsyncErrorRule(logic) {\n    this.logic.asyncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addMetadataRule(key, logic) {\n    this.logic.getMetadata(key).push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  getChild(key) {\n    if (!this.children.has(key)) {\n      this.children.set(key, new LogicNodeBuilder(this.depth + 1));\n    }\n    return this.children.get(key);\n  }\n  hasLogic(builder) {\n    return this === builder;\n  }\n}\nclass LeafLogicNode {\n  builder;\n  predicates;\n  depth;\n  logic;\n  constructor(builder, predicates, depth) {\n    this.builder = builder;\n    this.predicates = predicates;\n    this.depth = depth;\n    this.logic = builder ? createLogic(builder, predicates, depth) : new LogicContainer([]);\n  }\n  getChild(key) {\n    const childBuilders = this.builder ? getAllChildBuilders(this.builder, key) : [];\n    if (childBuilders.length === 0) {\n      return new LeafLogicNode(undefined, [], this.depth + 1);\n    } else if (childBuilders.length === 1) {\n      const {\n        builder,\n        predicates\n      } = childBuilders[0];\n      return new LeafLogicNode(builder, [...this.predicates, ...predicates.map(p => bindLevel(p, this.depth))], this.depth + 1);\n    } else {\n      const builtNodes = childBuilders.map(({\n        builder,\n        predicates\n      }) => new LeafLogicNode(builder, [...this.predicates, ...predicates.map(p => bindLevel(p, this.depth))], this.depth + 1));\n      return new CompositeLogicNode(builtNodes);\n    }\n  }\n  hasLogic(builder) {\n    return this.builder?.hasLogic(builder) ?? false;\n  }\n}\nclass CompositeLogicNode {\n  all;\n  logic;\n  constructor(all) {\n    this.all = all;\n    this.logic = new LogicContainer([]);\n    for (const node of all) {\n      this.logic.mergeIn(node.logic);\n    }\n  }\n  getChild(key) {\n    return new CompositeLogicNode(this.all.flatMap(child => child.getChild(key)));\n  }\n  hasLogic(builder) {\n    return this.all.some(node => node.hasLogic(builder));\n  }\n}\nfunction getAllChildBuilders(builder, key) {\n  if (builder instanceof LogicNodeBuilder) {\n    return builder.all.flatMap(({\n      builder,\n      predicate\n    }) => {\n      const children = getAllChildBuilders(builder, key);\n      if (predicate) {\n        return children.map(({\n          builder,\n          predicates\n        }) => ({\n          builder,\n          predicates: [...predicates, predicate]\n        }));\n      }\n      return children;\n    });\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    return [...(key !== DYNAMIC && builder.children.has(DYNAMIC) ? [{\n      builder: builder.getChild(DYNAMIC),\n      predicates: []\n    }] : []), ...(builder.children.has(key) ? [{\n      builder: builder.getChild(key),\n      predicates: []\n    }] : [])];\n  } else {\n    throw new _RuntimeError(1909, ngDevMode && 'Unknown LogicNodeBuilder type');\n  }\n}\nfunction createLogic(builder, predicates, depth) {\n  const logic = new LogicContainer(predicates);\n  if (builder instanceof LogicNodeBuilder) {\n    const builtNodes = builder.all.map(({\n      builder,\n      predicate\n    }) => new LeafLogicNode(builder, predicate ? [...predicates, bindLevel(predicate, depth)] : predicates, depth));\n    for (const node of builtNodes) {\n      logic.mergeIn(node.logic);\n    }\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    logic.mergeIn(builder.logic);\n  } else {\n    throw new _RuntimeError(1909, ngDevMode && 'Unknown LogicNodeBuilder type');\n  }\n  return logic;\n}\nfunction bindLevel(predicate, depth) {\n  return {\n    ...predicate,\n    depth: depth\n  };\n}\nconst PATH = /*#__PURE__*/Symbol('PATH');\nclass FieldPathNode {\n  keys;\n  parent;\n  keyInParent;\n  root;\n  children = /*#__PURE__*/new Map();\n  fieldPathProxy = /*#__PURE__*/new Proxy(this, FIELD_PATH_PROXY_HANDLER);\n  logicBuilder;\n  constructor(keys, root, parent, keyInParent) {\n    this.keys = keys;\n    this.parent = parent;\n    this.keyInParent = keyInParent;\n    this.root = root ?? this;\n    if (!parent) {\n      this.logicBuilder = LogicNodeBuilder.newRoot();\n    }\n  }\n  get builder() {\n    if (this.logicBuilder) {\n      return this.logicBuilder;\n    }\n    return this.parent.builder.getChild(this.keyInParent);\n  }\n  getChild(key) {\n    if (!this.children.has(key)) {\n      this.children.set(key, new FieldPathNode([...this.keys, key], this.root, this, key));\n    }\n    return this.children.get(key);\n  }\n  mergeIn(other, predicate) {\n    const path = other.compile();\n    this.builder.mergeIn(path.builder, predicate);\n  }\n  static unwrapFieldPath(formPath) {\n    return formPath[PATH];\n  }\n  static newRoot() {\n    return new FieldPathNode([], undefined, undefined, undefined);\n  }\n}\nconst FIELD_PATH_PROXY_HANDLER = {\n  get(node, property) {\n    if (property === PATH) {\n      return node;\n    }\n    return node.getChild(property).fieldPathProxy;\n  }\n};\nlet currentCompilingNode = undefined;\nconst compiledSchemas = /*#__PURE__*/new Map();\nclass SchemaImpl {\n  schemaFn;\n  constructor(schemaFn) {\n    this.schemaFn = schemaFn;\n  }\n  compile() {\n    if (compiledSchemas.has(this)) {\n      return compiledSchemas.get(this);\n    }\n    const path = FieldPathNode.newRoot();\n    compiledSchemas.set(this, path);\n    let prevCompilingNode = currentCompilingNode;\n    try {\n      currentCompilingNode = path;\n      this.schemaFn(path.fieldPathProxy);\n    } finally {\n      currentCompilingNode = prevCompilingNode;\n    }\n    return path;\n  }\n  static create(schema) {\n    if (schema instanceof SchemaImpl) {\n      return schema;\n    }\n    return new SchemaImpl(schema);\n  }\n  static rootCompile(schema) {\n    try {\n      compiledSchemas.clear();\n      if (schema === undefined) {\n        return FieldPathNode.newRoot();\n      }\n      if (schema instanceof SchemaImpl) {\n        return schema.compile();\n      }\n      return new SchemaImpl(schema).compile();\n    } finally {\n      compiledSchemas.clear();\n    }\n  }\n}\nfunction isSchemaOrSchemaFn(value) {\n  return value instanceof SchemaImpl || typeof value === 'function';\n}\nfunction assertPathIsCurrent(path) {\n  if (currentCompilingNode !== FieldPathNode.unwrapFieldPath(path).root) {\n    throw new _RuntimeError(1908, ngDevMode && `A FieldPath can only be used directly within the Schema that owns it, **not** outside of it or within a sub-schema.`);\n  }\n}\nfunction metadata(path, key, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addMetadataRule(key, logic);\n  return key;\n}\nconst MetadataReducer = {\n  list() {\n    return {\n      reduce: (acc, item) => item === undefined ? acc : [...acc, item],\n      getInitial: () => []\n    };\n  },\n  min() {\n    return {\n      reduce: (acc, item) => {\n        if (acc === undefined || item === undefined) {\n          return acc ?? item;\n        }\n        return Math.min(acc, item);\n      },\n      getInitial: () => undefined\n    };\n  },\n  max() {\n    return {\n      reduce: (prev, next) => {\n        if (prev === undefined || next === undefined) {\n          return prev ?? next;\n        }\n        return Math.max(prev, next);\n      },\n      getInitial: () => undefined\n    };\n  },\n  or() {\n    return {\n      reduce: (prev, next) => prev || next,\n      getInitial: () => false\n    };\n  },\n  and() {\n    return {\n      reduce: (prev, next) => prev && next,\n      getInitial: () => true\n    };\n  },\n  override\n};\nfunction override(getInitial) {\n  return {\n    reduce: (_, item) => item,\n    getInitial: () => getInitial?.()\n  };\n}\nclass MetadataKey {\n  reducer;\n  create;\n  brand;\n  constructor(reducer, create) {\n    this.reducer = reducer;\n    this.create = create;\n  }\n}\nfunction createMetadataKey(reducer) {\n  return new MetadataKey(reducer ?? MetadataReducer.override());\n}\nfunction createManagedMetadataKey(create, reducer) {\n  return new MetadataKey(reducer ?? MetadataReducer.override(), create);\n}\nconst REQUIRED = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.or());\nconst MIN = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.max());\nconst MAX = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.min());\nconst MIN_LENGTH = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.max());\nconst MAX_LENGTH = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.min());\nconst PATTERN = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.list());\nfunction calculateValidationSelfStatus(state) {\n  if (state.errors().length > 0) {\n    return 'invalid';\n  }\n  if (state.pending()) {\n    return 'unknown';\n  }\n  return 'valid';\n}\nclass FieldValidationState {\n  node;\n  constructor(node) {\n    this.node = node;\n  }\n  rawSyncTreeErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return [...this.node.logicNode.logic.syncTreeErrors.compute(this.node.context), ...(this.node.structure.parent?.validationState.rawSyncTreeErrors() ?? [])];\n  }, ...(ngDevMode ? [{\n    debugName: \"rawSyncTreeErrors\"\n  }] : []));\n  syncErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return [...this.node.logicNode.logic.syncErrors.compute(this.node.context), ...this.syncTreeErrors(), ...normalizeErrors(this.node.submitState.submissionErrors())];\n  }, ...(ngDevMode ? [{\n    debugName: \"syncErrors\"\n  }] : []));\n  syncValid = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return true;\n    }\n    return this.node.structure.reduceChildren(this.syncErrors().length === 0, (child, value) => value && child.validationState.syncValid(), shortCircuitFalse);\n  }, ...(ngDevMode ? [{\n    debugName: \"syncValid\"\n  }] : []));\n  syncTreeErrors = /*#__PURE__*/computed(() => this.rawSyncTreeErrors().filter(err => err.fieldTree === this.node.fieldTree), ...(ngDevMode ? [{\n    debugName: \"syncTreeErrors\"\n  }] : []));\n  rawAsyncErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return [...this.node.logicNode.logic.asyncErrors.compute(this.node.context), ...(this.node.structure.parent?.validationState.rawAsyncErrors() ?? [])];\n  }, ...(ngDevMode ? [{\n    debugName: \"rawAsyncErrors\"\n  }] : []));\n  asyncErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return this.rawAsyncErrors().filter(err => err === 'pending' || err.fieldTree === this.node.fieldTree);\n  }, ...(ngDevMode ? [{\n    debugName: \"asyncErrors\"\n  }] : []));\n  parseErrors = /*#__PURE__*/computed(() => this.node.formFieldBindings().flatMap(field => field.parseErrors()), ...(ngDevMode ? [{\n    debugName: \"parseErrors\"\n  }] : []));\n  errors = /*#__PURE__*/computed(() => [...this.parseErrors(), ...this.syncErrors(), ...this.asyncErrors().filter(err => err !== 'pending')], ...(ngDevMode ? [{\n    debugName: \"errors\"\n  }] : []));\n  errorSummary = /*#__PURE__*/computed(() => {\n    const errors = this.node.structure.reduceChildren(this.errors(), (child, result) => [...result, ...child.errorSummary()]);\n    if (typeof ngServerMode === 'undefined' || !ngServerMode) {\n      untracked(() => errors.sort(compareErrorPosition));\n    }\n    return errors;\n  }, ...(ngDevMode ? [{\n    debugName: \"errorSummary\"\n  }] : []));\n  pending = /*#__PURE__*/computed(() => this.node.structure.reduceChildren(this.asyncErrors().includes('pending'), (child, value) => value || child.validationState.asyncErrors().includes('pending')), ...(ngDevMode ? [{\n    debugName: \"pending\"\n  }] : []));\n  status = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return 'valid';\n    }\n    let ownStatus = calculateValidationSelfStatus(this);\n    return this.node.structure.reduceChildren(ownStatus, (child, value) => {\n      if (value === 'invalid' || child.validationState.status() === 'invalid') {\n        return 'invalid';\n      } else if (value === 'unknown' || child.validationState.status() === 'unknown') {\n        return 'unknown';\n      }\n      return 'valid';\n    }, v => v === 'invalid');\n  }, ...(ngDevMode ? [{\n    debugName: \"status\"\n  }] : []));\n  valid = /*#__PURE__*/computed(() => this.status() === 'valid', ...(ngDevMode ? [{\n    debugName: \"valid\"\n  }] : []));\n  invalid = /*#__PURE__*/computed(() => this.status() === 'invalid', ...(ngDevMode ? [{\n    debugName: \"invalid\"\n  }] : []));\n  shouldSkipValidation = /*#__PURE__*/computed(() => this.node.hidden() || this.node.disabled() || this.node.readonly(), ...(ngDevMode ? [{\n    debugName: \"shouldSkipValidation\"\n  }] : []));\n}\nfunction normalizeErrors(error) {\n  if (error === undefined) {\n    return [];\n  }\n  if (isArray(error)) {\n    return error;\n  }\n  return [error];\n}\nfunction addDefaultField(errors, fieldTree) {\n  if (isArray(errors)) {\n    for (const error of errors) {\n      error.fieldTree ??= fieldTree;\n    }\n  } else if (errors) {\n    errors.fieldTree ??= fieldTree;\n  }\n  return errors;\n}\nfunction getFirstBoundElement(error) {\n  if (error.formField) return error.formField.element;\n  return error.fieldTree().formFieldBindings().reduce((el, binding) => {\n    if (!el || !binding.element) return el ?? binding.element;\n    return el.compareDocumentPosition(binding.element) & Node.DOCUMENT_POSITION_PRECEDING ? binding.element : el;\n  }, undefined);\n}\nfunction compareErrorPosition(a, b) {\n  const aEl = getFirstBoundElement(a);\n  const bEl = getFirstBoundElement(b);\n  if (aEl === bEl) return 0;\n  if (aEl === undefined || bEl === undefined) return aEl === undefined ? 1 : -1;\n  return aEl.compareDocumentPosition(bEl) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;\n}\nconst DEBOUNCER = /*#__PURE__*/createMetadataKey();\nclass FieldNodeContext {\n  node;\n  cache = /*#__PURE__*/new WeakMap();\n  constructor(node) {\n    this.node = node;\n  }\n  resolve(target) {\n    if (!this.cache.has(target)) {\n      const resolver = computed(() => {\n        const targetPathNode = FieldPathNode.unwrapFieldPath(target);\n        let field = this.node;\n        let stepsRemaining = getBoundPathDepth();\n        while (stepsRemaining > 0 || !field.structure.logic.hasLogic(targetPathNode.root.builder)) {\n          stepsRemaining--;\n          field = field.structure.parent;\n          if (field === undefined) {\n            throw new _RuntimeError(1900, ngDevMode && 'Path is not part of this field tree.');\n          }\n        }\n        for (let key of targetPathNode.keys) {\n          field = field.structure.getChild(key);\n          if (field === undefined) {\n            throw new _RuntimeError(1901, ngDevMode && `Cannot resolve path .${targetPathNode.keys.join('.')} relative to field ${['<root>', ...this.node.structure.pathKeys()].join('.')}.`);\n          }\n        }\n        return field.fieldTree;\n      }, ...(ngDevMode ? [{\n        debugName: \"resolver\"\n      }] : []));\n      this.cache.set(target, resolver);\n    }\n    return this.cache.get(target)();\n  }\n  get fieldTree() {\n    return this.node.fieldProxy;\n  }\n  get state() {\n    return this.node;\n  }\n  get value() {\n    return this.node.structure.value;\n  }\n  get key() {\n    return this.node.structure.keyInParent;\n  }\n  get pathKeys() {\n    return this.node.structure.pathKeys;\n  }\n  index = /*#__PURE__*/computed(() => {\n    const key = this.key();\n    if (!isArray(untracked(this.node.structure.parent.value))) {\n      throw new _RuntimeError(1906, ngDevMode && 'Cannot access index, parent field is not an array.');\n    }\n    return Number(key);\n  }, ...(ngDevMode ? [{\n    debugName: \"index\"\n  }] : []));\n  fieldTreeOf = p => this.resolve(p);\n  stateOf = p => this.resolve(p)();\n  valueOf = p => {\n    const result = this.resolve(p)().value();\n    if (result instanceof AbstractControl) {\n      throw new _RuntimeError(1907, ngDevMode && `Tried to read an 'AbstractControl' value from a 'form()'. Did you mean to use 'compatForm()' instead?`);\n    }\n    return result;\n  };\n}\nclass FieldMetadataState {\n  node;\n  metadata = /*#__PURE__*/new Map();\n  constructor(node) {\n    this.node = node;\n    for (const key of this.node.logicNode.logic.getMetadataKeys()) {\n      if (key.create) {\n        const logic = this.node.logicNode.logic.getMetadata(key);\n        const result = untracked(() => runInInjectionContext(this.node.structure.injector, () => key.create(computed(() => logic.compute(this.node.context)))));\n        this.metadata.set(key, result);\n      }\n    }\n  }\n  get(key) {\n    if (this.has(key)) {\n      if (!this.metadata.has(key)) {\n        if (key.create) {\n          throw new _RuntimeError(1912, ngDevMode && 'Managed metadata cannot be created lazily');\n        }\n        const logic = this.node.logicNode.logic.getMetadata(key);\n        this.metadata.set(key, computed(() => logic.compute(this.node.context)));\n      }\n    }\n    return this.metadata.get(key);\n  }\n  has(key) {\n    return this.node.logicNode.logic.hasMetadata(key);\n  }\n}\nconst FIELD_PROXY_HANDLER = {\n  get(getTgt, p, receiver) {\n    const tgt = getTgt();\n    const child = tgt.structure.getChild(p);\n    if (child !== undefined) {\n      return child.fieldTree;\n    }\n    const value = untracked(tgt.value);\n    if (isArray(value)) {\n      if (p === 'length') {\n        return tgt.value().length;\n      }\n      if (p === Symbol.iterator) {\n        return () => {\n          tgt.value();\n          return Array.prototype[Symbol.iterator].apply(tgt.fieldTree);\n        };\n      }\n    }\n    if (isObject(value)) {\n      if (p === Symbol.iterator) {\n        return function* () {\n          for (const key in receiver) {\n            yield [key, receiver[key]];\n          }\n        };\n      }\n    }\n    return undefined;\n  },\n  getOwnPropertyDescriptor(getTgt, prop) {\n    const value = untracked(getTgt().value);\n    const desc = Reflect.getOwnPropertyDescriptor(value, prop);\n    if (desc && !desc.configurable) {\n      desc.configurable = true;\n    }\n    return desc;\n  },\n  ownKeys(getTgt) {\n    const value = untracked(getTgt().value);\n    return typeof value === 'object' && value !== null ? Reflect.ownKeys(value) : [];\n  }\n};\nfunction deepSignal(source, prop) {\n  const read = computed(() => source()[prop()]);\n  read[SIGNAL] = source[SIGNAL];\n  read.set = value => {\n    source.update(current => valueForWrite(current, value, prop()));\n  };\n  read.update = fn => {\n    read.set(fn(untracked(read)));\n  };\n  read.asReadonly = () => read;\n  return read;\n}\nfunction valueForWrite(sourceValue, newPropValue, prop) {\n  if (isArray(sourceValue)) {\n    const newValue = [...sourceValue];\n    newValue[prop] = newPropValue;\n    return newValue;\n  } else {\n    return {\n      ...sourceValue,\n      [prop]: newPropValue\n    };\n  }\n}\nclass FieldNodeStructure {\n  logic;\n  node;\n  createChildNode;\n  identitySymbol = /*#__PURE__*/Symbol();\n  _injector = undefined;\n  get injector() {\n    this._injector ??= Injector.create({\n      providers: [],\n      parent: this.fieldManager.injector\n    });\n    return this._injector;\n  }\n  constructor(logic, node, createChildNode) {\n    this.logic = logic;\n    this.node = node;\n    this.createChildNode = createChildNode;\n  }\n  children() {\n    const map = this.childrenMap();\n    if (map === undefined) {\n      return [];\n    }\n    return Array.from(map.byPropertyKey.values()).map(child => untracked(child.reader));\n  }\n  getChild(key) {\n    const strKey = key.toString();\n    let reader = untracked(this.childrenMap)?.byPropertyKey.get(strKey)?.reader;\n    if (!reader) {\n      reader = this.createReader(strKey);\n    }\n    return reader();\n  }\n  reduceChildren(initialValue, fn, shortCircuit) {\n    const map = this.childrenMap();\n    if (!map) {\n      return initialValue;\n    }\n    let value = initialValue;\n    for (const child of map.byPropertyKey.values()) {\n      if (shortCircuit?.(value)) {\n        break;\n      }\n      value = fn(untracked(child.reader), value);\n    }\n    return value;\n  }\n  destroy() {\n    this.injector.destroy();\n  }\n  createKeyInParent(options, identityInParent, initialKeyInParent) {\n    if (options.kind === 'root') {\n      return ROOT_KEY_IN_PARENT;\n    }\n    if (identityInParent === undefined) {\n      const key = initialKeyInParent;\n      return computed(() => {\n        if (this.parent.structure.getChild(key) !== this.node) {\n          throw new _RuntimeError(1902, ngDevMode && `Orphan field, looking for property '${key}' of ${getDebugName(this.parent)}`);\n        }\n        return key;\n      });\n    } else {\n      let lastKnownKey = initialKeyInParent;\n      return computed(() => {\n        const parentValue = this.parent.structure.value();\n        if (!isArray(parentValue)) {\n          throw new _RuntimeError(1903, ngDevMode && `Orphan field, expected ${getDebugName(this.parent)} to be an array`);\n        }\n        const data = parentValue[lastKnownKey];\n        if (isObject(data) && data.hasOwnProperty(this.parent.structure.identitySymbol) && data[this.parent.structure.identitySymbol] === identityInParent) {\n          return lastKnownKey;\n        }\n        for (let i = 0; i < parentValue.length; i++) {\n          const data = parentValue[i];\n          if (isObject(data) && data.hasOwnProperty(this.parent.structure.identitySymbol) && data[this.parent.structure.identitySymbol] === identityInParent) {\n            return lastKnownKey = i.toString();\n          }\n        }\n        throw new _RuntimeError(1904, ngDevMode && `Orphan field, can't find element in array ${getDebugName(this.parent)}`);\n      });\n    }\n  }\n  createChildrenMap() {\n    return linkedSignal({\n      source: this.value,\n      computation: (value, previous) => {\n        if (!isObject(value)) {\n          return undefined;\n        }\n        const prevData = previous?.value ?? {\n          byPropertyKey: new Map()\n        };\n        let data;\n        const parentIsArray = isArray(value);\n        if (prevData !== undefined) {\n          if (parentIsArray) {\n            data = maybeRemoveStaleArrayFields(prevData, value, this.identitySymbol);\n          } else {\n            data = maybeRemoveStaleObjectFields(prevData, value);\n          }\n        }\n        for (const key of Object.keys(value)) {\n          let trackingKey = undefined;\n          const childValue = value[key];\n          if (childValue === undefined) {\n            if (prevData.byPropertyKey.has(key)) {\n              data ??= {\n                ...prevData\n              };\n              data.byPropertyKey.delete(key);\n            }\n            continue;\n          }\n          if (parentIsArray && isObject(childValue) && !isArray(childValue)) {\n            trackingKey = childValue[this.identitySymbol] ??= Symbol(ngDevMode ? `id:${globalId++}` : '');\n          }\n          let childNode;\n          if (trackingKey) {\n            if (!prevData.byTrackingKey?.has(trackingKey)) {\n              data ??= {\n                ...prevData\n              };\n              data.byTrackingKey ??= new Map();\n              data.byTrackingKey.set(trackingKey, this.createChildNode(key, trackingKey, parentIsArray));\n            }\n            childNode = (data ?? prevData).byTrackingKey.get(trackingKey);\n          }\n          const child = prevData.byPropertyKey.get(key);\n          if (child === undefined) {\n            data ??= {\n              ...prevData\n            };\n            data.byPropertyKey.set(key, {\n              reader: this.createReader(key),\n              node: childNode ?? this.createChildNode(key, trackingKey, parentIsArray)\n            });\n          } else if (childNode && childNode !== child.node) {\n            data ??= {\n              ...prevData\n            };\n            child.node = childNode;\n          }\n        }\n        return data ?? prevData;\n      }\n    });\n  }\n  createReader(key) {\n    return computed(() => this.childrenMap()?.byPropertyKey.get(key)?.node);\n  }\n}\nclass RootFieldNodeStructure extends FieldNodeStructure {\n  fieldManager;\n  value;\n  get parent() {\n    return undefined;\n  }\n  get root() {\n    return this.node;\n  }\n  get pathKeys() {\n    return ROOT_PATH_KEYS;\n  }\n  get keyInParent() {\n    return ROOT_KEY_IN_PARENT;\n  }\n  childrenMap;\n  constructor(node, logic, fieldManager, value, createChildNode) {\n    super(logic, node, createChildNode);\n    this.fieldManager = fieldManager;\n    this.value = value;\n    this.childrenMap = this.createChildrenMap();\n  }\n}\nclass ChildFieldNodeStructure extends FieldNodeStructure {\n  logic;\n  parent;\n  root;\n  pathKeys;\n  keyInParent;\n  value;\n  childrenMap;\n  get fieldManager() {\n    return this.root.structure.fieldManager;\n  }\n  constructor(node, logic, parent, identityInParent, initialKeyInParent, createChildNode) {\n    super(logic, node, createChildNode);\n    this.logic = logic;\n    this.parent = parent;\n    this.root = this.parent.structure.root;\n    this.keyInParent = this.createKeyInParent({\n      kind: 'child',\n      parent,\n      pathNode: undefined,\n      logic,\n      initialKeyInParent,\n      identityInParent,\n      fieldAdapter: undefined\n    }, identityInParent, initialKeyInParent);\n    this.pathKeys = computed(() => [...parent.structure.pathKeys(), this.keyInParent()], ...(ngDevMode ? [{\n      debugName: \"pathKeys\"\n    }] : []));\n    this.value = deepSignal(this.parent.structure.value, this.keyInParent);\n    this.childrenMap = this.createChildrenMap();\n    this.fieldManager.structures.add(this);\n  }\n}\nlet globalId = 0;\nconst ROOT_PATH_KEYS = /*#__PURE__*/computed(() => [], ...(ngDevMode ? [{\n  debugName: \"ROOT_PATH_KEYS\"\n}] : []));\nconst ROOT_KEY_IN_PARENT = /*#__PURE__*/computed(() => {\n  throw new _RuntimeError(1905, ngDevMode && 'The top-level field in the form has no parent.');\n}, ...(ngDevMode ? [{\n  debugName: \"ROOT_KEY_IN_PARENT\"\n}] : []));\nfunction getDebugName(node) {\n  return `<root>.${node.structure.pathKeys().join('.')}`;\n}\nfunction maybeRemoveStaleArrayFields(prevData, value, identitySymbol) {\n  let data;\n  const oldKeys = new Set(prevData.byPropertyKey.keys());\n  const oldTracking = new Set(prevData.byTrackingKey?.keys());\n  for (let i = 0; i < value.length; i++) {\n    const childValue = value[i];\n    oldKeys.delete(i.toString());\n    if (isObject(childValue) && childValue.hasOwnProperty(identitySymbol)) {\n      oldTracking.delete(childValue[identitySymbol]);\n    }\n  }\n  if (oldKeys.size > 0) {\n    data ??= {\n      ...prevData\n    };\n    for (const key of oldKeys) {\n      data.byPropertyKey.delete(key);\n    }\n  }\n  if (oldTracking.size > 0) {\n    data ??= {\n      ...prevData\n    };\n    for (const id of oldTracking) {\n      data.byTrackingKey?.delete(id);\n    }\n  }\n  return data;\n}\nfunction maybeRemoveStaleObjectFields(prevData, value) {\n  let data;\n  for (const key of prevData.byPropertyKey.keys()) {\n    if (!value.hasOwnProperty(key)) {\n      data ??= {\n        ...prevData\n      };\n      data.byPropertyKey.delete(key);\n    }\n  }\n  return data;\n}\nclass FieldSubmitState {\n  node;\n  selfSubmitting = /*#__PURE__*/signal(false, ...(ngDevMode ? [{\n    debugName: \"selfSubmitting\"\n  }] : []));\n  submissionErrors;\n  constructor(node) {\n    this.node = node;\n    this.submissionErrors = linkedSignal({\n      ...(ngDevMode ? {\n        debugName: \"submissionErrors\"\n      } : {}),\n      source: this.node.structure.value,\n      computation: () => []\n    });\n  }\n  submitting = /*#__PURE__*/computed(() => {\n    return this.selfSubmitting() || (this.node.structure.parent?.submitting() ?? false);\n  }, ...(ngDevMode ? [{\n    debugName: \"submitting\"\n  }] : []));\n}\nclass FieldNode {\n  structure;\n  validationState;\n  metadataState;\n  nodeState;\n  submitState;\n  fieldAdapter;\n  controlValue;\n  _context = undefined;\n  get context() {\n    return this._context ??= new FieldNodeContext(this);\n  }\n  fieldProxy = /*#__PURE__*/new Proxy(() => this, FIELD_PROXY_HANDLER);\n  pathNode;\n  constructor(options) {\n    this.pathNode = options.pathNode;\n    this.fieldAdapter = options.fieldAdapter;\n    this.structure = this.fieldAdapter.createStructure(this, options);\n    this.validationState = this.fieldAdapter.createValidationState(this, options);\n    this.nodeState = this.fieldAdapter.createNodeState(this, options);\n    this.metadataState = new FieldMetadataState(this);\n    this.submitState = new FieldSubmitState(this);\n    this.controlValue = this.controlValueSignal();\n  }\n  focusBoundControl(options) {\n    this.getBindingForFocus()?.focus(options);\n  }\n  getBindingForFocus() {\n    const own = this.formFieldBindings().filter(b => b.focus !== undefined).reduce(firstInDom, undefined);\n    if (own) return own;\n    return this.structure.children().map(child => child.getBindingForFocus()).reduce(firstInDom, undefined);\n  }\n  pendingSync = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"pendingSync\"\n    } : {}),\n    source: () => this.value(),\n    computation: (_source, previous) => {\n      previous?.value?.abort();\n      return undefined;\n    }\n  });\n  get fieldTree() {\n    return this.fieldProxy;\n  }\n  get logicNode() {\n    return this.structure.logic;\n  }\n  get value() {\n    return this.structure.value;\n  }\n  get keyInParent() {\n    return this.structure.keyInParent;\n  }\n  get errors() {\n    return this.validationState.errors;\n  }\n  get parseErrors() {\n    return this.validationState.parseErrors;\n  }\n  get errorSummary() {\n    return this.validationState.errorSummary;\n  }\n  get pending() {\n    return this.validationState.pending;\n  }\n  get valid() {\n    return this.validationState.valid;\n  }\n  get invalid() {\n    return this.validationState.invalid;\n  }\n  get dirty() {\n    return this.nodeState.dirty;\n  }\n  get touched() {\n    return this.nodeState.touched;\n  }\n  get disabled() {\n    return this.nodeState.disabled;\n  }\n  get disabledReasons() {\n    return this.nodeState.disabledReasons;\n  }\n  get hidden() {\n    return this.nodeState.hidden;\n  }\n  get readonly() {\n    return this.nodeState.readonly;\n  }\n  get formFieldBindings() {\n    return this.nodeState.formFieldBindings;\n  }\n  get submitting() {\n    return this.submitState.submitting;\n  }\n  get name() {\n    return this.nodeState.name;\n  }\n  get max() {\n    return this.metadata(MAX);\n  }\n  get maxLength() {\n    return this.metadata(MAX_LENGTH);\n  }\n  get min() {\n    return this.metadata(MIN);\n  }\n  get minLength() {\n    return this.metadata(MIN_LENGTH);\n  }\n  get pattern() {\n    return this.metadata(PATTERN) ?? EMPTY;\n  }\n  get required() {\n    return this.metadata(REQUIRED) ?? FALSE;\n  }\n  metadata(key) {\n    return this.metadataState.get(key);\n  }\n  hasMetadata(key) {\n    return this.metadataState.has(key);\n  }\n  markAsTouched() {\n    untracked(() => {\n      this.nodeState.markAsTouched();\n      this.flushSync();\n    });\n  }\n  markAsDirty() {\n    this.nodeState.markAsDirty();\n  }\n  markAsPristine() {\n    this.nodeState.markAsPristine();\n  }\n  markAsUntouched() {\n    this.nodeState.markAsUntouched();\n  }\n  reset(value) {\n    untracked(() => this._reset(value));\n  }\n  _reset(value) {\n    if (value !== undefined) {\n      this.value.set(value);\n    }\n    this.nodeState.markAsUntouched();\n    this.nodeState.markAsPristine();\n    for (const child of this.structure.children()) {\n      child._reset();\n    }\n  }\n  controlValueSignal() {\n    const controlValue = linkedSignal(this.value, ...(ngDevMode ? [{\n      debugName: \"controlValue\"\n    }] : []));\n    const {\n      set,\n      update\n    } = controlValue;\n    controlValue.set = newValue => {\n      set(newValue);\n      this.markAsDirty();\n      this.debounceSync();\n    };\n    controlValue.update = updateFn => {\n      update(updateFn);\n      this.markAsDirty();\n      this.debounceSync();\n    };\n    return controlValue;\n  }\n  sync() {\n    this.value.set(this.controlValue());\n  }\n  flushSync() {\n    const pending = this.pendingSync();\n    if (pending && !pending.signal.aborted) {\n      pending.abort();\n      this.sync();\n    }\n  }\n  async debounceSync() {\n    const debouncer = untracked(() => {\n      this.pendingSync()?.abort();\n      return this.nodeState.debouncer();\n    });\n    if (debouncer) {\n      const controller = new AbortController();\n      const promise = debouncer(controller.signal);\n      if (promise) {\n        this.pendingSync.set(controller);\n        await promise;\n        if (controller.signal.aborted) {\n          return;\n        }\n      }\n    }\n    this.sync();\n  }\n  static newRoot(fieldManager, value, pathNode, adapter) {\n    return adapter.newRoot(fieldManager, value, pathNode, adapter);\n  }\n  createStructure(options) {\n    return options.kind === 'root' ? new RootFieldNodeStructure(this, options.logic, options.fieldManager, options.value, this.newChild.bind(this)) : new ChildFieldNodeStructure(this, options.logic, options.parent, options.identityInParent, options.initialKeyInParent, this.newChild.bind(this));\n  }\n  newChild(key, trackingId, isArray) {\n    let childPath;\n    let childLogic;\n    if (isArray) {\n      childPath = this.pathNode.getChild(DYNAMIC);\n      childLogic = this.structure.logic.getChild(DYNAMIC);\n    } else {\n      childPath = this.pathNode.getChild(key);\n      childLogic = this.structure.logic.getChild(key);\n    }\n    return this.fieldAdapter.newChild({\n      kind: 'child',\n      parent: this,\n      pathNode: childPath,\n      logic: childLogic,\n      initialKeyInParent: key,\n      identityInParent: trackingId,\n      fieldAdapter: this.fieldAdapter\n    });\n  }\n}\nconst EMPTY = /*#__PURE__*/computed(() => [], ...(ngDevMode ? [{\n  debugName: \"EMPTY\"\n}] : []));\nconst FALSE = /*#__PURE__*/computed(() => false, ...(ngDevMode ? [{\n  debugName: \"FALSE\"\n}] : []));\nfunction firstInDom(a, b) {\n  if (!a) return b;\n  if (!b) return a;\n  const position = a.element.compareDocumentPosition(b.element);\n  return position & Node.DOCUMENT_POSITION_PRECEDING ? b : a;\n}\nclass FieldNodeState {\n  node;\n  selfTouched = /*#__PURE__*/signal(false, ...(ngDevMode ? [{\n    debugName: \"selfTouched\"\n  }] : []));\n  selfDirty = /*#__PURE__*/signal(false, ...(ngDevMode ? [{\n    debugName: \"selfDirty\"\n  }] : []));\n  markAsTouched() {\n    this.selfTouched.set(true);\n  }\n  markAsDirty() {\n    this.selfDirty.set(true);\n  }\n  markAsPristine() {\n    this.selfDirty.set(false);\n  }\n  markAsUntouched() {\n    this.selfTouched.set(false);\n  }\n  formFieldBindings = /*#__PURE__*/signal([], ...(ngDevMode ? [{\n    debugName: \"formFieldBindings\"\n  }] : []));\n  constructor(node) {\n    this.node = node;\n  }\n  dirty = /*#__PURE__*/computed(() => {\n    const selfDirtyValue = this.selfDirty() && !this.isNonInteractive();\n    return this.node.structure.reduceChildren(selfDirtyValue, (child, value) => value || child.nodeState.dirty(), shortCircuitTrue);\n  }, ...(ngDevMode ? [{\n    debugName: \"dirty\"\n  }] : []));\n  touched = /*#__PURE__*/computed(() => {\n    const selfTouchedValue = this.selfTouched() && !this.isNonInteractive();\n    return this.node.structure.reduceChildren(selfTouchedValue, (child, value) => value || child.nodeState.touched(), shortCircuitTrue);\n  }, ...(ngDevMode ? [{\n    debugName: \"touched\"\n  }] : []));\n  disabledReasons = /*#__PURE__*/computed(() => [...(this.node.structure.parent?.nodeState.disabledReasons() ?? []), ...this.node.logicNode.logic.disabledReasons.compute(this.node.context)], ...(ngDevMode ? [{\n    debugName: \"disabledReasons\"\n  }] : []));\n  disabled = /*#__PURE__*/computed(() => !!this.disabledReasons().length, ...(ngDevMode ? [{\n    debugName: \"disabled\"\n  }] : []));\n  readonly = /*#__PURE__*/computed(() => (this.node.structure.parent?.nodeState.readonly() || this.node.logicNode.logic.readonly.compute(this.node.context)) ?? false, ...(ngDevMode ? [{\n    debugName: \"readonly\"\n  }] : []));\n  hidden = /*#__PURE__*/computed(() => (this.node.structure.parent?.nodeState.hidden() || this.node.logicNode.logic.hidden.compute(this.node.context)) ?? false, ...(ngDevMode ? [{\n    debugName: \"hidden\"\n  }] : []));\n  name = /*#__PURE__*/computed(() => {\n    const parent = this.node.structure.parent;\n    if (!parent) {\n      return this.node.structure.fieldManager.rootName;\n    }\n    return `${parent.name()}.${this.node.structure.keyInParent()}`;\n  }, ...(ngDevMode ? [{\n    debugName: \"name\"\n  }] : []));\n  debouncer = /*#__PURE__*/computed(() => {\n    if (this.node.logicNode.logic.hasMetadata(DEBOUNCER)) {\n      const debouncerLogic = this.node.logicNode.logic.getMetadata(DEBOUNCER);\n      const debouncer = debouncerLogic.compute(this.node.context);\n      if (debouncer) {\n        return signal => debouncer(this.node.context, signal);\n      }\n    }\n    return this.node.structure.parent?.nodeState.debouncer?.();\n  }, ...(ngDevMode ? [{\n    debugName: \"debouncer\"\n  }] : []));\n  isNonInteractive = /*#__PURE__*/computed(() => this.hidden() || this.disabled() || this.readonly(), ...(ngDevMode ? [{\n    debugName: \"isNonInteractive\"\n  }] : []));\n}\nclass BasicFieldAdapter {\n  newRoot(fieldManager, value, pathNode, adapter) {\n    return new FieldNode({\n      kind: 'root',\n      fieldManager,\n      value,\n      pathNode,\n      logic: pathNode.builder.build(),\n      fieldAdapter: adapter\n    });\n  }\n  newChild(options) {\n    return new FieldNode(options);\n  }\n  createNodeState(node) {\n    return new FieldNodeState(node);\n  }\n  createValidationState(node) {\n    return new FieldValidationState(node);\n  }\n  createStructure(node, options) {\n    return node.createStructure(options);\n  }\n}\nclass FormFieldManager {\n  injector;\n  rootName;\n  submitOptions;\n  constructor(injector, rootName, submitOptions) {\n    this.injector = injector;\n    this.rootName = rootName ?? `${this.injector.get(APP_ID)}.form${nextFormId++}`;\n    this.submitOptions = submitOptions;\n  }\n  structures = /*#__PURE__*/new Set();\n  createFieldManagementEffect(root) {\n    effect(() => {\n      const liveStructures = new Set();\n      this.markStructuresLive(root, liveStructures);\n      for (const structure of this.structures) {\n        if (!liveStructures.has(structure)) {\n          this.structures.delete(structure);\n          untracked(() => structure.destroy());\n        }\n      }\n    }, {\n      injector: this.injector\n    });\n  }\n  markStructuresLive(structure, liveStructures) {\n    liveStructures.add(structure);\n    for (const child of structure.children()) {\n      this.markStructuresLive(child.structure, liveStructures);\n    }\n  }\n}\nlet nextFormId = 0;\nfunction normalizeFormArgs(args) {\n  let model;\n  let schema;\n  let options;\n  if (args.length === 3) {\n    [model, schema, options] = args;\n  } else if (args.length === 2) {\n    if (isSchemaOrSchemaFn(args[1])) {\n      [model, schema] = args;\n    } else {\n      [model, options] = args;\n    }\n  } else {\n    [model] = args;\n  }\n  return [model, schema, options];\n}\nfunction form(...args) {\n  const [model, schema, options] = normalizeFormArgs(args);\n  const injector = options?.injector ?? inject(Injector);\n  const pathNode = runInInjectionContext(injector, () => SchemaImpl.rootCompile(schema));\n  const fieldManager = new FormFieldManager(injector, options?.name, options?.submission);\n  const adapter = options?.adapter ?? new BasicFieldAdapter();\n  const fieldRoot = FieldNode.newRoot(fieldManager, model, pathNode, adapter);\n  fieldManager.createFieldManagementEffect(fieldRoot.structure);\n  return fieldRoot.fieldTree;\n}\nfunction applyEach(path, schema) {\n  assertPathIsCurrent(path);\n  const elementPath = FieldPathNode.unwrapFieldPath(path).getChild(DYNAMIC).fieldPathProxy;\n  apply(elementPath, schema);\n}\nfunction apply(path, schema) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema));\n}\nfunction applyWhen(path, logic, schema) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema), {\n    fn: logic,\n    path\n  });\n}\nfunction applyWhenValue(path, predicate, schema) {\n  applyWhen(path, ({\n    value\n  }) => predicate(value()), schema);\n}\nasync function submit(form, options) {\n  const node = untracked(form);\n  const field = options === undefined ? node.structure.root.fieldProxy : form;\n  const detail = {\n    root: node.structure.root.fieldProxy,\n    submitted: form\n  };\n  options = typeof options === 'function' ? {\n    action: options\n  } : options ?? node.structure.fieldManager.submitOptions;\n  const action = options?.action;\n  if (!action) {\n    throw new _RuntimeError(1915, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Cannot submit form with no submit action. Specify the action when creating the form, or as an additional argument to `submit()`.');\n  }\n  const onInvalid = options?.onInvalid;\n  const ignoreValidators = options?.ignoreValidators ?? 'pending';\n  let shouldRunAction = true;\n  untracked(() => {\n    markAllAsTouched(node);\n    if (ignoreValidators === 'none') {\n      shouldRunAction = node.valid();\n    } else if (ignoreValidators === 'pending') {\n      shouldRunAction = !node.invalid();\n    }\n  });\n  try {\n    if (shouldRunAction) {\n      node.submitState.selfSubmitting.set(true);\n      const errors = await untracked(() => action?.(field, detail));\n      errors && setSubmissionErrors(node, errors);\n      return !errors || isArray(errors) && errors.length === 0;\n    } else {\n      untracked(() => onInvalid?.(field, detail));\n    }\n    return false;\n  } finally {\n    node.submitState.selfSubmitting.set(false);\n  }\n}\nfunction schema(fn) {\n  return SchemaImpl.create(fn);\n}\nfunction markAllAsTouched(node) {\n  if (node.validationState.shouldSkipValidation()) {\n    return;\n  }\n  node.markAsTouched();\n  for (const child of node.structure.children()) {\n    markAllAsTouched(child);\n  }\n}\nfunction setSubmissionErrors(submittedField, errors) {\n  if (!isArray(errors)) {\n    errors = [errors];\n  }\n  const errorsByField = new Map();\n  for (const error of errors) {\n    const errorWithField = addDefaultField(error, submittedField.fieldTree);\n    const field = errorWithField.fieldTree();\n    let fieldErrors = errorsByField.get(field);\n    if (!fieldErrors) {\n      fieldErrors = [];\n      errorsByField.set(field, fieldErrors);\n    }\n    fieldErrors.push(errorWithField);\n  }\n  for (const [field, fieldErrors] of errorsByField) {\n    field.submitState.submissionErrors.set(fieldErrors);\n  }\n}\nclass CompatValidationError {\n  kind = 'compat';\n  control;\n  fieldTree;\n  context;\n  message;\n  constructor({\n    context,\n    kind,\n    control\n  }) {\n    this.context = context;\n    this.kind = kind;\n    this.control = control;\n  }\n}\nfunction signalErrorsToValidationErrors(errors) {\n  if (errors.length === 0) {\n    return null;\n  }\n  const errObj = {};\n  for (const error of errors) {\n    errObj[error.kind] = error instanceof CompatValidationError ? error.context : error;\n  }\n  return errObj;\n}\nfunction reactiveErrorsToSignalErrors(errors, control) {\n  if (errors === null) {\n    return [];\n  }\n  return Object.entries(errors).map(([kind, context]) => {\n    return new CompatValidationError({\n      context,\n      kind,\n      control\n    });\n  });\n}\nfunction extractNestedReactiveErrors(control) {\n  const errors = [];\n  if (control.errors) {\n    errors.push(...reactiveErrorsToSignalErrors(control.errors, control));\n  }\n  if (control instanceof FormGroup || control instanceof FormArray) {\n    for (const c of Object.values(control.controls)) {\n      errors.push(...extractNestedReactiveErrors(c));\n    }\n  }\n  return errors;\n}\nexport { BasicFieldAdapter, CompatValidationError, DEBOUNCER, FieldNode, FieldNodeState, FieldNodeStructure, FieldPathNode, MAX, MAX_LENGTH, MIN, MIN_LENGTH, MetadataKey, MetadataReducer, PATTERN, REQUIRED, addDefaultField, apply, applyEach, applyWhen, applyWhenValue, assertPathIsCurrent, calculateValidationSelfStatus, createManagedMetadataKey, createMetadataKey, extractNestedReactiveErrors, form, getInjectorFromOptions, metadata, normalizeFormArgs, schema, signalErrorsToValidationErrors, submit };\n","/**\n * @license Angular v21.2.0-rc.0\n * (c) 2010-2026 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { InjectionToken, ÉµisPromise as _isPromise, resource, linkedSignal, inject, ÉµRuntimeError as _RuntimeError, untracked, input, Renderer2, DestroyRef, computed, Injector, ElementRef, signal, afterRenderEffect, effect, ÉµformatRuntimeError as _formatRuntimeError, Directive } from '@angular/core';\nimport { assertPathIsCurrent, FieldPathNode, addDefaultField, metadata, createMetadataKey, MAX, MAX_LENGTH, MIN, MIN_LENGTH, PATTERN, REQUIRED, createManagedMetadataKey, DEBOUNCER, signalErrorsToValidationErrors, submit } from './_validation_errors-chunk.mjs';\nexport { MetadataKey, MetadataReducer, apply, applyEach, applyWhen, applyWhenValue, form, schema } from './_validation_errors-chunk.mjs';\nimport { httpResource } from '@angular/common/http';\nimport { Validators, NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';\nimport '@angular/core/primitives/signals';\nconst SIGNAL_FORMS_CONFIG = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'SIGNAL_FORMS_CONFIG' : '');\nfunction provideSignalFormsConfig(config) {\n  return [{\n    provide: SIGNAL_FORMS_CONFIG,\n    useValue: config\n  }];\n}\nfunction disabled(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addDisabledReasonRule(ctx => {\n    let result = true;\n    if (typeof logic === 'string') {\n      result = logic;\n    } else if (logic) {\n      result = logic(ctx);\n    }\n    if (typeof result === 'string') {\n      return {\n        fieldTree: ctx.fieldTree,\n        message: result\n      };\n    }\n    return result ? {\n      fieldTree: ctx.fieldTree\n    } : undefined;\n  });\n}\nfunction hidden(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addHiddenRule(logic);\n}\nfunction readonly(path, logic = () => true) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addReadonlyRule(logic);\n}\nfunction getLengthOrSize(value) {\n  const v = value;\n  return typeof v.length === 'number' ? v.length : v.size;\n}\nfunction getOption(opt, ctx) {\n  return opt instanceof Function ? opt(ctx) : opt;\n}\nfunction isEmpty(value) {\n  if (typeof value === 'number') {\n    return isNaN(value);\n  }\n  return value === '' || value === false || value == null;\n}\nfunction validate(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncErrorRule(ctx => {\n    return addDefaultField(logic(ctx), ctx.fieldTree);\n  });\n}\nfunction requiredError(options) {\n  return new RequiredValidationError(options);\n}\nfunction minError(min, options) {\n  return new MinValidationError(min, options);\n}\nfunction maxError(max, options) {\n  return new MaxValidationError(max, options);\n}\nfunction minLengthError(minLength, options) {\n  return new MinLengthValidationError(minLength, options);\n}\nfunction maxLengthError(maxLength, options) {\n  return new MaxLengthValidationError(maxLength, options);\n}\nfunction patternError(pattern, options) {\n  return new PatternValidationError(pattern, options);\n}\nfunction emailError(options) {\n  return new EmailValidationError(options);\n}\nclass BaseNgValidationError {\n  __brand = undefined;\n  kind = '';\n  fieldTree;\n  message;\n  constructor(options) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\nclass RequiredValidationError extends BaseNgValidationError {\n  kind = 'required';\n}\nclass MinValidationError extends BaseNgValidationError {\n  min;\n  kind = 'min';\n  constructor(min, options) {\n    super(options);\n    this.min = min;\n  }\n}\nclass MaxValidationError extends BaseNgValidationError {\n  max;\n  kind = 'max';\n  constructor(max, options) {\n    super(options);\n    this.max = max;\n  }\n}\nclass MinLengthValidationError extends BaseNgValidationError {\n  minLength;\n  kind = 'minLength';\n  constructor(minLength, options) {\n    super(options);\n    this.minLength = minLength;\n  }\n}\nclass MaxLengthValidationError extends BaseNgValidationError {\n  maxLength;\n  kind = 'maxLength';\n  constructor(maxLength, options) {\n    super(options);\n    this.maxLength = maxLength;\n  }\n}\nclass PatternValidationError extends BaseNgValidationError {\n  pattern;\n  kind = 'pattern';\n  constructor(pattern, options) {\n    super(options);\n    this.pattern = pattern;\n  }\n}\nclass EmailValidationError extends BaseNgValidationError {\n  kind = 'email';\n}\nclass NativeInputParseError extends BaseNgValidationError {\n  kind = 'parse';\n}\nconst NgValidationError = BaseNgValidationError;\nconst EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nfunction email(path, config) {\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    if (!EMAIL_REGEXP.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return emailError({\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction max(path, maxValue, config) {\n  const MAX_MEMO = metadata(path, createMetadataKey(), ctx => typeof maxValue === 'number' ? maxValue : maxValue(ctx));\n  metadata(path, MAX, ({\n    state\n  }) => state.metadata(MAX_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const max = ctx.state.metadata(MAX_MEMO)();\n    if (max === undefined || Number.isNaN(max)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value);\n    if (numValue > max) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxError(max, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction maxLength(path, maxLength, config) {\n  const MAX_LENGTH_MEMO = metadata(path, createMetadataKey(), ctx => typeof maxLength === 'number' ? maxLength : maxLength(ctx));\n  metadata(path, MAX_LENGTH, ({\n    state\n  }) => state.metadata(MAX_LENGTH_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const maxLength = ctx.state.metadata(MAX_LENGTH_MEMO)();\n    if (maxLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) > maxLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxLengthError(maxLength, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction min(path, minValue, config) {\n  const MIN_MEMO = metadata(path, createMetadataKey(), ctx => typeof minValue === 'number' ? minValue : minValue(ctx));\n  metadata(path, MIN, ({\n    state\n  }) => state.metadata(MIN_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const min = ctx.state.metadata(MIN_MEMO)();\n    if (min === undefined || Number.isNaN(min)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value);\n    if (numValue < min) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minError(min, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction minLength(path, minLength, config) {\n  const MIN_LENGTH_MEMO = metadata(path, createMetadataKey(), ctx => typeof minLength === 'number' ? minLength : minLength(ctx));\n  metadata(path, MIN_LENGTH, ({\n    state\n  }) => state.metadata(MIN_LENGTH_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const minLength = ctx.state.metadata(MIN_LENGTH_MEMO)();\n    if (minLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) < minLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minLengthError(minLength, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction pattern(path, pattern, config) {\n  const PATTERN_MEMO = metadata(path, createMetadataKey(), ctx => pattern instanceof RegExp ? pattern : pattern(ctx));\n  metadata(path, PATTERN, ({\n    state\n  }) => state.metadata(PATTERN_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const pattern = ctx.state.metadata(PATTERN_MEMO)();\n    if (pattern === undefined) {\n      return undefined;\n    }\n    if (!pattern.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return patternError(pattern, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction required(path, config) {\n  const REQUIRED_MEMO = metadata(path, createMetadataKey(), ctx => config?.when ? config.when(ctx) : true);\n  metadata(path, REQUIRED, ({\n    state\n  }) => state.metadata(REQUIRED_MEMO)());\n  validate(path, ctx => {\n    if (ctx.state.metadata(REQUIRED_MEMO)() && isEmpty(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return requiredError({\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction validateAsync(path, opts) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  const RESOURCE = createManagedMetadataKey(opts.factory);\n  metadata(path, RESOURCE, ctx => {\n    const node = ctx.stateOf(path);\n    const validationState = node.validationState;\n    if (validationState.shouldSkipValidation() || !validationState.syncValid()) {\n      return undefined;\n    }\n    return opts.params(ctx);\n  });\n  pathNode.builder.addAsyncErrorRule(ctx => {\n    const res = ctx.state.metadata(RESOURCE);\n    let errors;\n    switch (res.status()) {\n      case 'idle':\n        return undefined;\n      case 'loading':\n      case 'reloading':\n        return 'pending';\n      case 'resolved':\n      case 'local':\n        if (!res.hasValue()) {\n          return undefined;\n        }\n        errors = opts.onSuccess(res.value(), ctx);\n        return addDefaultField(errors, ctx.fieldTree);\n      case 'error':\n        errors = opts.onError(res.error(), ctx);\n        return addDefaultField(errors, ctx.fieldTree);\n    }\n  });\n}\nfunction validateTree(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncTreeErrorRule(ctx => addDefaultField(logic(ctx), ctx.fieldTree));\n}\nfunction validateStandardSchema(path, schema) {\n  const VALIDATOR_MEMO = metadata(path, createMetadataKey(), ctx => {\n    const resolvedSchema = typeof schema === 'function' ? schema(ctx) : schema;\n    return resolvedSchema ? resolvedSchema['~standard'].validate(ctx.value()) : undefined;\n  });\n  validateTree(path, ({\n    state,\n    fieldTreeOf\n  }) => {\n    const result = state.metadata(VALIDATOR_MEMO)();\n    if (!result || _isPromise(result)) {\n      return [];\n    }\n    return result?.issues?.map(issue => standardIssueToFormTreeError(fieldTreeOf(path), issue)) ?? [];\n  });\n  validateAsync(path, {\n    params: ({\n      state\n    }) => {\n      const result = state.metadata(VALIDATOR_MEMO)();\n      return result && _isPromise(result) ? result : undefined;\n    },\n    factory: params => {\n      return resource({\n        params,\n        loader: async ({\n          params\n        }) => (await params)?.issues ?? []\n      });\n    },\n    onSuccess: (issues, {\n      fieldTreeOf\n    }) => {\n      return issues.map(issue => standardIssueToFormTreeError(fieldTreeOf(path), issue));\n    },\n    onError: () => {}\n  });\n}\nfunction standardSchemaError(issue, options) {\n  return new StandardSchemaValidationError(issue, options);\n}\nfunction standardIssueToFormTreeError(fieldTree, issue) {\n  let target = fieldTree;\n  for (const pathPart of issue.path ?? []) {\n    const pathKey = typeof pathPart === 'object' ? pathPart.key : pathPart;\n    target = target[pathKey];\n  }\n  return addDefaultField(standardSchemaError(issue, {\n    message: issue.message\n  }), target);\n}\nclass StandardSchemaValidationError extends BaseNgValidationError {\n  issue;\n  kind = 'standardSchema';\n  constructor(issue, options) {\n    super(options);\n    this.issue = issue;\n  }\n}\nfunction validateHttp(path, opts) {\n  validateAsync(path, {\n    params: opts.request,\n    factory: request => httpResource(request, opts.options),\n    onSuccess: opts.onSuccess,\n    onError: opts.onError\n  });\n}\nfunction debounce(path, durationOrDebouncer) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  const debouncer = typeof durationOrDebouncer === 'function' ? durationOrDebouncer : durationOrDebouncer > 0 ? debounceForDuration(durationOrDebouncer) : immediate;\n  pathNode.builder.addMetadataRule(DEBOUNCER, () => debouncer);\n}\nfunction debounceForDuration(durationInMilliseconds) {\n  return (_context, abortSignal) => {\n    return new Promise(resolve => {\n      let timeoutId;\n      const onAbort = () => {\n        clearTimeout(timeoutId);\n        resolve();\n      };\n      timeoutId = setTimeout(() => {\n        abortSignal.removeEventListener('abort', onAbort);\n        resolve();\n      }, durationInMilliseconds);\n      abortSignal.addEventListener('abort', onAbort, {\n        once: true\n      });\n    });\n  };\n}\nfunction immediate() {}\nconst FORM_FIELD_PARSE_ERRORS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'FORM_FIELD_PARSE_ERRORS' : '');\nfunction createParser(getValue, setValue, parse) {\n  const errors = linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"errors\"\n    } : {}),\n    source: getValue,\n    computation: () => []\n  });\n  const setRawValue = rawValue => {\n    const result = parse(rawValue);\n    errors.set(result.errors ?? []);\n    if (result.value !== undefined) {\n      setValue(result.value);\n    }\n  };\n  return {\n    errors: errors.asReadonly(),\n    setRawValue\n  };\n}\nfunction transformedValue(value, options) {\n  const {\n    parse,\n    format\n  } = options;\n  const parser = createParser(value, value.set, parse);\n  const formFieldParseErrors = inject(FORM_FIELD_PARSE_ERRORS, {\n    self: true,\n    optional: true\n  });\n  if (formFieldParseErrors) {\n    formFieldParseErrors.set(parser.errors);\n  }\n  const rawValue = linkedSignal(() => format(value()), ...(ngDevMode ? [{\n    debugName: \"rawValue\"\n  }] : []));\n  const result = rawValue;\n  result.parseErrors = parser.errors;\n  const originalSet = result.set.bind(result);\n  result.set = newRawValue => {\n    parser.setRawValue(newRawValue);\n    originalSet(newRawValue);\n  };\n  result.update = updateFn => {\n    result.set(updateFn(rawValue()));\n  };\n  return result;\n}\nclass InteropNgControl {\n  field;\n  constructor(field) {\n    this.field = field;\n  }\n  control = this;\n  get value() {\n    return this.field().value();\n  }\n  get valid() {\n    return this.field().valid();\n  }\n  get invalid() {\n    return this.field().invalid();\n  }\n  get pending() {\n    return this.field().pending();\n  }\n  get disabled() {\n    return this.field().disabled();\n  }\n  get enabled() {\n    return !this.field().disabled();\n  }\n  get errors() {\n    return signalErrorsToValidationErrors(this.field().errors());\n  }\n  get pristine() {\n    return !this.field().dirty();\n  }\n  get dirty() {\n    return this.field().dirty();\n  }\n  get touched() {\n    return this.field().touched();\n  }\n  get untouched() {\n    return !this.field().touched();\n  }\n  get status() {\n    if (this.field().disabled()) {\n      return 'DISABLED';\n    }\n    if (this.field().valid()) {\n      return 'VALID';\n    }\n    if (this.field().invalid()) {\n      return 'INVALID';\n    }\n    if (this.field().pending()) {\n      return 'PENDING';\n    }\n    throw new _RuntimeError(1910, ngDevMode && 'Unknown form control status');\n  }\n  valueAccessor = null;\n  hasValidator(validator) {\n    if (validator === Validators.required) {\n      return this.field().required();\n    }\n    return false;\n  }\n  updateValueAndValidity() {}\n}\nconst FIELD_STATE_KEY_TO_CONTROL_BINDING = {\n  disabled: 'disabled',\n  disabledReasons: 'disabledReasons',\n  dirty: 'dirty',\n  errors: 'errors',\n  hidden: 'hidden',\n  invalid: 'invalid',\n  max: 'max',\n  maxLength: 'maxLength',\n  min: 'min',\n  minLength: 'minLength',\n  name: 'name',\n  pattern: 'pattern',\n  pending: 'pending',\n  readonly: 'readonly',\n  required: 'required',\n  touched: 'touched'\n};\nconst CONTROL_BINDING_TO_FIELD_STATE_KEY = /* @__PURE__ */(() => {\n  const map = {};\n  for (const key of Object.keys(FIELD_STATE_KEY_TO_CONTROL_BINDING)) {\n    map[FIELD_STATE_KEY_TO_CONTROL_BINDING[key]] = key;\n  }\n  return map;\n})();\nfunction readFieldStateBindingValue(fieldState, key) {\n  const property = CONTROL_BINDING_TO_FIELD_STATE_KEY[key];\n  return fieldState[property]?.();\n}\nconst CONTROL_BINDING_NAMES = /* @__PURE__ */(() => Object.values(FIELD_STATE_KEY_TO_CONTROL_BINDING))();\nfunction createBindings() {\n  return {};\n}\nfunction bindingUpdated(bindings, key, value) {\n  if (bindings[key] !== value) {\n    bindings[key] = value;\n    return true;\n  }\n  return false;\n}\nfunction isNativeFormElement(element) {\n  return element.tagName === 'INPUT' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA';\n}\nfunction isNumericFormElement(element) {\n  if (element.tagName !== 'INPUT') {\n    return false;\n  }\n  const type = element.type;\n  return type === 'date' || type === 'datetime-local' || type === 'month' || type === 'number' || type === 'range' || type === 'time' || type === 'week';\n}\nfunction isTextualFormElement(element) {\n  return element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\n}\nfunction getNativeControlValue(element, currentValue) {\n  let modelValue;\n  if (element.validity.badInput) {\n    return {\n      errors: [new NativeInputParseError()]\n    };\n  }\n  switch (element.type) {\n    case 'checkbox':\n      return {\n        value: element.checked\n      };\n    case 'number':\n    case 'range':\n    case 'datetime-local':\n      modelValue = untracked(currentValue);\n      if (typeof modelValue === 'number' || modelValue === null) {\n        return {\n          value: element.value === '' ? null : element.valueAsNumber\n        };\n      }\n      break;\n    case 'date':\n    case 'month':\n    case 'time':\n    case 'week':\n      modelValue = untracked(currentValue);\n      if (modelValue === null || modelValue instanceof Date) {\n        return {\n          value: element.valueAsDate\n        };\n      } else if (typeof modelValue === 'number') {\n        return {\n          value: element.valueAsNumber\n        };\n      }\n      break;\n  }\n  return {\n    value: element.value\n  };\n}\nfunction setNativeControlValue(element, value) {\n  switch (element.type) {\n    case 'checkbox':\n      element.checked = value;\n      return;\n    case 'radio':\n      element.checked = value === element.value;\n      return;\n    case 'number':\n    case 'range':\n    case 'datetime-local':\n      if (typeof value === 'number') {\n        setNativeNumberControlValue(element, value);\n        return;\n      } else if (value === null) {\n        element.value = '';\n        return;\n      }\n      break;\n    case 'date':\n    case 'month':\n    case 'time':\n    case 'week':\n      if (value === null || value instanceof Date) {\n        element.valueAsDate = value;\n        return;\n      } else if (typeof value === 'number') {\n        setNativeNumberControlValue(element, value);\n        return;\n      }\n  }\n  element.value = value;\n}\nfunction setNativeNumberControlValue(element, value) {\n  if (isNaN(value)) {\n    element.value = '';\n  } else {\n    element.valueAsNumber = value;\n  }\n}\nfunction setNativeDomProperty(renderer, element, name, value) {\n  switch (name) {\n    case 'name':\n      renderer.setAttribute(element, name, value);\n      break;\n    case 'disabled':\n    case 'readonly':\n    case 'required':\n      if (value) {\n        renderer.setAttribute(element, name, '');\n      } else {\n        renderer.removeAttribute(element, name);\n      }\n      break;\n    case 'max':\n    case 'min':\n    case 'minLength':\n    case 'maxLength':\n      if (value !== undefined) {\n        renderer.setAttribute(element, name, value.toString());\n      } else {\n        renderer.removeAttribute(element, name);\n      }\n      break;\n  }\n}\nfunction customControlCreate(host, parent) {\n  host.listenToCustomControlModel(value => parent.state().controlValue.set(value));\n  host.listenToCustomControlOutput('touchedChange', () => parent.state().markAsTouched());\n  parent.registerAsBinding(host.customControl);\n  const bindings = createBindings();\n  return () => {\n    const state = parent.state();\n    const controlValue = state.controlValue();\n    if (bindingUpdated(bindings, 'controlValue', controlValue)) {\n      host.setCustomControlModelInput(controlValue);\n    }\n    for (const name of CONTROL_BINDING_NAMES) {\n      let value;\n      if (name === 'errors') {\n        value = parent.errors();\n      } else {\n        value = readFieldStateBindingValue(state, name);\n      }\n      if (bindingUpdated(bindings, name, value)) {\n        host.setInputOnDirectives(name, value);\n        if (parent.elementAcceptsNativeProperty(name) && !host.customControlHasInput(name)) {\n          setNativeDomProperty(parent.renderer, parent.nativeFormElement, name, value);\n        }\n      }\n    }\n  };\n}\nfunction cvaControlCreate(host, parent) {\n  parent.controlValueAccessor.registerOnChange(value => parent.state().controlValue.set(value));\n  parent.controlValueAccessor.registerOnTouched(() => parent.state().markAsTouched());\n  parent.registerAsBinding();\n  const bindings = createBindings();\n  return () => {\n    const fieldState = parent.state();\n    const value = fieldState.value();\n    if (bindingUpdated(bindings, 'controlValue', value)) {\n      untracked(() => parent.controlValueAccessor.writeValue(value));\n    }\n    for (const name of CONTROL_BINDING_NAMES) {\n      const value = readFieldStateBindingValue(fieldState, name);\n      if (bindingUpdated(bindings, name, value)) {\n        const propertyWasSet = host.setInputOnDirectives(name, value);\n        if (name === 'disabled' && parent.controlValueAccessor.setDisabledState) {\n          untracked(() => parent.controlValueAccessor.setDisabledState(value));\n        } else if (!propertyWasSet && parent.elementAcceptsNativeProperty(name)) {\n          setNativeDomProperty(parent.renderer, parent.nativeFormElement, name, value);\n        }\n      }\n    }\n  };\n}\nfunction observeSelectMutations(select, onMutation, destroyRef) {\n  if (typeof MutationObserver !== 'function') {\n    return;\n  }\n  const observer = new MutationObserver(mutations => {\n    if (mutations.some(m => isRelevantSelectMutation(m))) {\n      onMutation();\n    }\n  });\n  observer.observe(select, {\n    attributes: true,\n    attributeFilter: ['value'],\n    characterData: true,\n    childList: true,\n    subtree: true\n  });\n  destroyRef.onDestroy(() => observer.disconnect());\n}\nfunction isRelevantSelectMutation(mutation) {\n  if (mutation.type === 'childList' || mutation.type === 'characterData') {\n    if (mutation.target instanceof Comment) {\n      return false;\n    }\n    for (const node of mutation.addedNodes) {\n      if (!(node instanceof Comment)) {\n        return true;\n      }\n    }\n    for (const node of mutation.removedNodes) {\n      if (!(node instanceof Comment)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (mutation.type === 'attributes' && mutation.target instanceof HTMLOptionElement) {\n    return true;\n  }\n  return false;\n}\nfunction nativeControlCreate(host, parent, parseErrorsSource) {\n  let updateMode = false;\n  const input = parent.nativeFormElement;\n  const parser = createParser(() => parent.state().value(), rawValue => parent.state().controlValue.set(rawValue), () => getNativeControlValue(input, parent.state().value));\n  parseErrorsSource.set(parser.errors);\n  host.listenToDom('input', () => parser.setRawValue(undefined));\n  host.listenToDom('blur', () => parent.state().markAsTouched());\n  parent.registerAsBinding();\n  if (input.tagName === 'SELECT') {\n    observeSelectMutations(input, () => {\n      if (!updateMode) {\n        return;\n      }\n      input.value = parent.state().controlValue();\n    }, parent.destroyRef);\n  }\n  const bindings = createBindings();\n  return () => {\n    const state = parent.state();\n    const controlValue = state.controlValue();\n    if (bindingUpdated(bindings, 'controlValue', controlValue)) {\n      setNativeControlValue(input, controlValue);\n    }\n    for (const name of CONTROL_BINDING_NAMES) {\n      const value = readFieldStateBindingValue(state, name);\n      if (bindingUpdated(bindings, name, value)) {\n        host.setInputOnDirectives(name, value);\n        if (parent.elementAcceptsNativeProperty(name)) {\n          setNativeDomProperty(parent.renderer, input, name, value);\n        }\n      }\n    }\n    updateMode = true;\n  };\n}\nconst ÉµNgFieldDirective = /*#__PURE__*/Symbol();\nconst FORM_FIELD = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'FORM_FIELD' : '');\nlet FormField = /*#__PURE__*/(() => {\n  class FormField {\n    field = input.required({\n      ...(ngDevMode ? {\n        debugName: \"field\"\n      } : {}),\n      alias: 'formField'\n    });\n    renderer = inject(Renderer2);\n    destroyRef = inject(DestroyRef);\n    state = computed(() => this.field()(), ...(ngDevMode ? [{\n      debugName: \"state\"\n    }] : []));\n    injector = inject(Injector);\n    element = inject(ElementRef).nativeElement;\n    elementIsNativeFormElement = isNativeFormElement(this.element);\n    elementAcceptsNumericValues = isNumericFormElement(this.element);\n    elementAcceptsTextualValues = isTextualFormElement(this.element);\n    nativeFormElement = this.elementIsNativeFormElement ? this.element : undefined;\n    focuser = options => this.element.focus(options);\n    controlValueAccessors = inject(NG_VALUE_ACCESSOR, {\n      optional: true,\n      self: true\n    });\n    config = inject(SIGNAL_FORMS_CONFIG, {\n      optional: true\n    });\n    parseErrorsSource = signal(undefined, ...(ngDevMode ? [{\n      debugName: \"parseErrorsSource\"\n    }] : []));\n    _interopNgControl;\n    get interopNgControl() {\n      return this._interopNgControl ??= new InteropNgControl(this.state);\n    }\n    parseErrors = computed(() => this.parseErrorsSource()?.().map(err => ({\n      ...err,\n      fieldTree: untracked(this.state).fieldTree,\n      formField: this\n    })) ?? [], ...(ngDevMode ? [{\n      debugName: \"parseErrors\"\n    }] : []));\n    errors = computed(() => this.state().errors().filter(err => !err.formField || err.formField === this), ...(ngDevMode ? [{\n      debugName: \"errors\"\n    }] : []));\n    isFieldBinding = false;\n    get controlValueAccessor() {\n      return this.controlValueAccessors?.[0] ?? this.interopNgControl?.valueAccessor ?? undefined;\n    }\n    installClassBindingEffect() {\n      const classes = Object.entries(this.config?.classes ?? {}).map(([className, computation]) => [className, computed(() => computation(this))]);\n      if (classes.length === 0) {\n        return;\n      }\n      const bindings = createBindings();\n      afterRenderEffect({\n        write: () => {\n          for (const [className, computation] of classes) {\n            const active = computation();\n            if (bindingUpdated(bindings, className, active)) {\n              if (active) {\n                this.renderer.addClass(this.element, className);\n              } else {\n                this.renderer.removeClass(this.element, className);\n              }\n            }\n          }\n        }\n      }, {\n        injector: this.injector\n      });\n    }\n    focus(options) {\n      this.focuser(options);\n    }\n    registerAsBinding(bindingOptions) {\n      if (this.isFieldBinding) {\n        throw new _RuntimeError(1913, typeof ngDevMode !== 'undefined' && ngDevMode && 'FormField already registered as a binding');\n      }\n      this.isFieldBinding = true;\n      this.installClassBindingEffect();\n      if (bindingOptions?.focus) {\n        this.focuser = focusOptions => bindingOptions.focus(focusOptions);\n      }\n      effect(onCleanup => {\n        const fieldNode = this.state();\n        fieldNode.nodeState.formFieldBindings.update(controls => [...controls, this]);\n        onCleanup(() => {\n          fieldNode.nodeState.formFieldBindings.update(controls => controls.filter(c => c !== this));\n        });\n      }, {\n        injector: this.injector\n      });\n      if (typeof ngDevMode !== 'undefined' && ngDevMode) {\n        effect(() => {\n          const fieldNode = this.state();\n          if (fieldNode.hidden()) {\n            const path = fieldNode.structure.pathKeys().join('.') || '<root>';\n            console.warn(_formatRuntimeError(1916, `Field '${path}' is hidden but is being rendered. ` + `Hidden fields should be removed from the DOM using @if.`));\n          }\n        }, {\n          injector: this.injector\n        });\n      }\n    }\n    [ÉµNgFieldDirective];\n    ÉµngControlCreate(host) {\n      if (host.hasPassThrough) {\n        return;\n      }\n      if (this.controlValueAccessor) {\n        this.ÉµngControlUpdate = cvaControlCreate(host, this);\n      } else if (host.customControl) {\n        this.ÉµngControlUpdate = customControlCreate(host, this);\n      } else if (this.elementIsNativeFormElement) {\n        this.ÉµngControlUpdate = nativeControlCreate(host, this, this.parseErrorsSource);\n      } else {\n        throw new _RuntimeError(1914, typeof ngDevMode !== 'undefined' && ngDevMode && `${host.descriptor} is an invalid [formField] directive host. The host must be a native form control ` + `(such as <input>', '<select>', or '<textarea>') or a custom form control with a 'value' or ` + `'checked' model.`);\n      }\n    }\n    ÉµngControlUpdate;\n    elementAcceptsNativeProperty(key) {\n      if (!this.elementIsNativeFormElement) {\n        return false;\n      }\n      switch (key) {\n        case 'min':\n        case 'max':\n          return this.elementAcceptsNumericValues;\n        case 'minLength':\n        case 'maxLength':\n          return this.elementAcceptsTextualValues;\n        case 'disabled':\n        case 'required':\n        case 'readonly':\n        case 'name':\n          return true;\n        default:\n          return false;\n      }\n    }\n    static Éµfac = function FormField_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FormField)();\n    };\n    static Éµdir = /* @__PURE__ */i0.ÉµÉµdefineDirective({\n      type: FormField,\n      selectors: [[\"\", \"formField\", \"\"]],\n      inputs: {\n        field: [1, \"formField\", \"field\"]\n      },\n      exportAs: [\"formField\"],\n      features: [i0.ÉµÉµProvidersFeature([{\n        provide: FORM_FIELD,\n        useExisting: FormField\n      }, {\n        provide: NgControl,\n        useFactory: () => inject(FormField).interopNgControl\n      }, {\n        provide: FORM_FIELD_PARSE_ERRORS,\n        useFactory: () => inject(FormField).parseErrorsSource\n      }]), i0.ÉµÉµControlFeature(\"formField\")]\n    });\n  }\n  return FormField;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormRoot = /*#__PURE__*/(() => {\n  class FormRoot {\n    fieldTree = input.required({\n      ...(ngDevMode ? {\n        debugName: \"fieldTree\"\n      } : {}),\n      alias: 'formRoot'\n    });\n    onSubmit(event) {\n      event.preventDefault();\n      submit(this.fieldTree());\n    }\n    static Éµfac = function FormRoot_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || FormRoot)();\n    };\n    static Éµdir = /* @__PURE__ */i0.ÉµÉµdefineDirective({\n      type: FormRoot,\n      selectors: [[\"form\", \"formRoot\", \"\"]],\n      hostAttrs: [\"novalidate\", \"\"],\n      hostBindings: function FormRoot_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ÉµÉµlistener(\"submit\", function FormRoot_submit_HostBindingHandler($event) {\n            return ctx.onSubmit($event);\n          });\n        }\n      },\n      inputs: {\n        fieldTree: [1, \"formRoot\", \"fieldTree\"]\n      }\n    });\n  }\n  return FormRoot;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { BaseNgValidationError, EmailValidationError, FORM_FIELD, FormField, FormRoot, MAX, MAX_LENGTH, MIN, MIN_LENGTH, MaxLengthValidationError, MaxValidationError, MinLengthValidationError, MinValidationError, NativeInputParseError, NgValidationError, PATTERN, PatternValidationError, REQUIRED, RequiredValidationError, StandardSchemaValidationError, createManagedMetadataKey, createMetadataKey, debounce, disabled, email, emailError, hidden, max, maxError, maxLength, maxLengthError, metadata, min, minError, minLength, minLengthError, pattern, patternError, provideSignalFormsConfig, readonly, required, requiredError, standardSchemaError, submit, transformedValue, validate, validateAsync, validateHttp, validateStandardSchema, validateTree, ÉµNgFieldDirective };\n","export const validationMessages = {\n  required: 'To pole jest wymagane',\n  email: 'NieprawidÅowy format',\n};\n"],"mappings":"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","names":["boundPathDepth","getBoundPathDepth","setBoundPathDepthForResolution","fn","depth","args","shortCircuitFalse","value","shortCircuitTrue","isArray","value","isObject","DYNAMIC","IGNORED","AbstractLogic","predicates","logicFn","wrapWithPredicates","other","fns","fn","BooleanOrLogic","arg","f","result","ArrayMergeIgnoreLogic","_ArrayMergeIgnoreLogic","e","ignore","prev","ArrayMergeLogic","MetadataMergeLogic","key","ctx","acc","i","item","predicate","predicateField","depthDiff","untracked","LogicContainer","metadataLogic","AbstractLogicNodeBuilder","depth","LeafLogicNode","LogicNodeBuilder","_LogicNodeBuilder","logic","children","builder","subBuilder","setBoundPathDepthForResolution","NonMergeableLogicNodeBuilder","_LeafLogicNode","createLogic","childBuilders","getAllChildBuilders","p","bindLevel","builtNodes","CompositeLogicNode","_CompositeLogicNode","all","node","child","RuntimeError","__spreadProps","__spreadValues","PATH","FieldPathNode","_FieldPathNode","FIELD_PATH_PROXY_HANDLER","keys","root","parent","keyInParent","path","formPath","property","currentCompilingNode","compiledSchemas","SchemaImpl","_SchemaImpl","schemaFn","prevCompilingNode","schema","isSchemaOrSchemaFn","assertPathIsCurrent","metadata","MetadataReducer","next","override","getInitial","_","MetadataKey","reducer","create","createMetadataKey","REQUIRED","createMetadataKey","MetadataReducer","MIN","MAX","MIN_LENGTH","MAX_LENGTH","PATTERN","calculateValidationSelfStatus","state","FieldValidationState","node","computed","normalizeErrors","child","value","shortCircuitFalse","err","field","errors","result","untracked","compareErrorPosition","ownStatus","v","error","isArray","addDefaultField","fieldTree","getFirstBoundElement","el","binding","a","b","aEl","bEl","DEBOUNCER","FieldNodeContext","target","resolver","targetPathNode","FieldPathNode","stepsRemaining","getBoundPathDepth","RuntimeError","key","p","AbstractControl","FieldMetadataState","logic","runInInjectionContext","FIELD_PROXY_HANDLER","getTgt","receiver","tgt","isObject","prop","desc","deepSignal","source","read","SIGNAL","current","valueForWrite","fn","sourceValue","newPropValue","newValue","__spreadProps","__spreadValues","FieldNodeStructure","Injector","createChildNode","map","strKey","reader","initialValue","shortCircuit","options","identityInParent","initialKeyInParent","ROOT_KEY_IN_PARENT","lastKnownKey","parentValue","data","i","linkedSignal","previous","prevData","parentIsArray","maybeRemoveStaleArrayFields","maybeRemoveStaleObjectFields","trackingKey","childValue","childNode","RootFieldNodeStructure","ROOT_PATH_KEYS","fieldManager","ChildFieldNodeStructure","parent","ROOT_PATH_KEYS","computed","ROOT_KEY_IN_PARENT","RuntimeError","maybeRemoveStaleArrayFields","prevData","value","identitySymbol","data","oldKeys","oldTracking","i","childValue","isObject","__spreadValues","key","id","maybeRemoveStaleObjectFields","FieldSubmitState","signal","node","linkedSignal","computed","FieldNode","FieldNodeContext","FIELD_PROXY_HANDLER","options","FieldMetadataState","own","b","firstInDom","child","_source","previous","MAX","MAX_LENGTH","MIN","MIN_LENGTH","PATTERN","EMPTY","REQUIRED","FALSE","untracked","controlValue","set","update","newValue","updateFn","pending","debouncer","controller","promise","fieldManager","pathNode","adapter","RootFieldNodeStructure","ChildFieldNodeStructure","trackingId","isArray","childPath","childLogic","DYNAMIC","a","FieldNodeState","selfDirtyValue","shortCircuitTrue","selfTouchedValue","parent","DEBOUNCER","BasicFieldAdapter","FieldValidationState","FormFieldManager","injector","rootName","submitOptions","APP_ID","nextFormId","root","effect","liveStructures","structure","normalizeFormArgs","args","model","schema","isSchemaOrSchemaFn","form","inject","Injector","runInInjectionContext","SchemaImpl","fieldRoot","submit","form","options","node","untracked","field","detail","action","RuntimeError","onInvalid","ignoreValidators","shouldRunAction","markAllAsTouched","errors","setSubmissionErrors","isArray","markAllAsTouched","node","child","setSubmissionErrors","submittedField","errors","isArray","errorsByField","error","errorWithField","addDefaultField","field","fieldErrors","CompatValidationError","context","kind","control","signalErrorsToValidationErrors","errObj","SIGNAL_FORMS_CONFIG","InjectionToken","hidden","path","logic","assertPathIsCurrent","FieldPathNode","getLengthOrSize","value","v","getOption","opt","ctx","isEmpty","validate","path","logic","assertPathIsCurrent","FieldPathNode","addDefaultField","requiredError","options","RequiredValidationError","minLengthError","minLength","options","MinLengthValidationError","emailError","options","EmailValidationError","BaseNgValidationError","RequiredValidationError","MinLengthValidationError","BaseNgValidationError","minLength","options","EmailValidationError","BaseNgValidationError","NativeInputParseError","EMAIL_REGEXP","email","path","config","validate","ctx","isEmpty","getOption","emailError","minLength","path","config","MIN_LENGTH_MEMO","metadata","createMetadataKey","ctx","MIN_LENGTH","state","validate","isEmpty","getLengthOrSize","getOption","minLengthError","required","path","config","REQUIRED_MEMO","metadata","createMetadataKey","ctx","REQUIRED","state","validate","isEmpty","getOption","requiredError","FORM_FIELD_PARSE_ERRORS","InjectionToken","createParser","getValue","setValue","parse","errors","linkedSignal","setRawValue","rawValue","result","InteropNgControl","field","signalErrorsToValidationErrors","RuntimeError","validator","Validators","FIELD_STATE_KEY_TO_CONTROL_BINDING","CONTROL_BINDING_TO_FIELD_STATE_KEY","map","key","readFieldStateBindingValue","fieldState","property","CONTROL_BINDING_NAMES","createBindings","bindingUpdated","bindings","value","isNativeFormElement","element","isNumericFormElement","type","isTextualFormElement","getNativeControlValue","currentValue","modelValue","NativeInputParseError","untracked","setNativeControlValue","setNativeNumberControlValue","setNativeDomProperty","renderer","name","customControlCreate","host","parent","state","controlValue","cvaControlCreate","propertyWasSet","observeSelectMutations","select","onMutation","destroyRef","observer","mutations","m","isRelevantSelectMutation","mutation","node","nativeControlCreate","parseErrorsSource","updateMode","input","parser","createParser","rawValue","ÉµNgFieldDirective","FORM_FIELD","InjectionToken","FormField","inject","Renderer2","DestroyRef","computed","Injector","ElementRef","options","NG_VALUE_ACCESSOR","SIGNAL_FORMS_CONFIG","signal","err","__spreadProps","__spreadValues","classes","className","computation","afterRenderEffect","active","bindingOptions","focusOptions","effect","onCleanup","fieldNode","controls","c","__ngFactoryType__","ÉµÉµdefineDirective","ÉµÉµProvidersFeature","NgControl","FORM_FIELD_PARSE_ERRORS","ÉµÉµControlFeature","validationMessages","required","email"],"x_google_ignoreList":[0,1]}