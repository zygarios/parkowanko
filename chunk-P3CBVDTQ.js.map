{"version":3,"sources":["node_modules/@angular/forms/fesm2022/_structure-chunk.mjs","node_modules/@angular/forms/fesm2022/signals.mjs","src/app/_others/_helpers/validation-messages.ts"],"sourcesContent":["/**\n * @license Angular v21.0.5\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { untracked, computed, runInInjectionContext, Injector, linkedSignal, signal, APP_ID, effect, inject } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\nimport { SIGNAL } from '@angular/core/primitives/signals';\nlet boundPathDepth = 0;\nfunction getBoundPathDepth() {\n  return boundPathDepth;\n}\nfunction setBoundPathDepthForResolution(fn, depth) {\n  return (...args) => {\n    try {\n      boundPathDepth = depth;\n      return fn(...args);\n    } finally {\n      boundPathDepth = 0;\n    }\n  };\n}\nfunction shortCircuitFalse(value) {\n  return !value;\n}\nfunction shortCircuitTrue(value) {\n  return value;\n}\nfunction getInjectorFromOptions(options) {\n  if (options.kind === 'root') {\n    return options.fieldManager.injector;\n  }\n  return options.parent.structure.root.structure.injector;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isObject(value) {\n  return (typeof value === 'object' || typeof value === 'function') && value != null;\n}\nconst DYNAMIC = /*#__PURE__*/Symbol();\nconst IGNORED = /*#__PURE__*/Symbol();\nclass AbstractLogic {\n  predicates;\n  fns = [];\n  constructor(predicates) {\n    this.predicates = predicates;\n  }\n  push(logicFn) {\n    this.fns.push(wrapWithPredicates(this.predicates, logicFn));\n  }\n  mergeIn(other) {\n    const fns = this.predicates ? other.fns.map(fn => wrapWithPredicates(this.predicates, fn)) : other.fns;\n    this.fns.push(...fns);\n  }\n}\nclass BooleanOrLogic extends AbstractLogic {\n  get defaultValue() {\n    return false;\n  }\n  compute(arg) {\n    return this.fns.some(f => {\n      const result = f(arg);\n      return result && result !== IGNORED;\n    });\n  }\n}\nclass ArrayMergeIgnoreLogic extends AbstractLogic {\n  ignore;\n  static ignoreNull(predicates) {\n    return new ArrayMergeIgnoreLogic(predicates, e => e === null);\n  }\n  constructor(predicates, ignore) {\n    super(predicates);\n    this.ignore = ignore;\n  }\n  get defaultValue() {\n    return [];\n  }\n  compute(arg) {\n    return this.fns.reduce((prev, f) => {\n      const value = f(arg);\n      if (value === undefined || value === IGNORED) {\n        return prev;\n      } else if (isArray(value)) {\n        return [...prev, ...(this.ignore ? value.filter(e => !this.ignore(e)) : value)];\n      } else {\n        if (this.ignore && this.ignore(value)) {\n          return prev;\n        }\n        return [...prev, value];\n      }\n    }, []);\n  }\n}\nclass ArrayMergeLogic extends ArrayMergeIgnoreLogic {\n  constructor(predicates) {\n    super(predicates, undefined);\n  }\n}\nclass MetadataMergeLogic extends AbstractLogic {\n  key;\n  get defaultValue() {\n    return this.key.reducer.getInitial();\n  }\n  constructor(predicates, key) {\n    super(predicates);\n    this.key = key;\n  }\n  compute(ctx) {\n    if (this.fns.length === 0) {\n      return this.key.reducer.getInitial();\n    }\n    let acc = this.key.reducer.getInitial();\n    for (let i = 0; i < this.fns.length; i++) {\n      const item = this.fns[i](ctx);\n      if (item !== IGNORED) {\n        acc = this.key.reducer.reduce(acc, item);\n      }\n    }\n    return acc;\n  }\n}\nfunction wrapWithPredicates(predicates, logicFn) {\n  if (predicates.length === 0) {\n    return logicFn;\n  }\n  return arg => {\n    for (const predicate of predicates) {\n      let predicateField = arg.stateOf(predicate.path);\n      const depthDiff = untracked(predicateField.structure.pathKeys).length - predicate.depth;\n      for (let i = 0; i < depthDiff; i++) {\n        predicateField = predicateField.structure.parent;\n      }\n      if (!predicate.fn(predicateField.context)) {\n        return IGNORED;\n      }\n    }\n    return logicFn(arg);\n  };\n}\nclass LogicContainer {\n  predicates;\n  hidden;\n  disabledReasons;\n  readonly;\n  syncErrors;\n  syncTreeErrors;\n  asyncErrors;\n  metadata = /*#__PURE__*/new Map();\n  constructor(predicates) {\n    this.predicates = predicates;\n    this.hidden = new BooleanOrLogic(predicates);\n    this.disabledReasons = new ArrayMergeLogic(predicates);\n    this.readonly = new BooleanOrLogic(predicates);\n    this.syncErrors = ArrayMergeIgnoreLogic.ignoreNull(predicates);\n    this.syncTreeErrors = ArrayMergeIgnoreLogic.ignoreNull(predicates);\n    this.asyncErrors = ArrayMergeIgnoreLogic.ignoreNull(predicates);\n  }\n  hasMetadata(key) {\n    return this.metadata.has(key);\n  }\n  getMetadataKeys() {\n    return this.metadata.keys();\n  }\n  getMetadata(key) {\n    if (!this.metadata.has(key)) {\n      this.metadata.set(key, new MetadataMergeLogic(this.predicates, key));\n    }\n    return this.metadata.get(key);\n  }\n  mergeIn(other) {\n    this.hidden.mergeIn(other.hidden);\n    this.disabledReasons.mergeIn(other.disabledReasons);\n    this.readonly.mergeIn(other.readonly);\n    this.syncErrors.mergeIn(other.syncErrors);\n    this.syncTreeErrors.mergeIn(other.syncTreeErrors);\n    this.asyncErrors.mergeIn(other.asyncErrors);\n    for (const key of other.getMetadataKeys()) {\n      const metadataLogic = other.metadata.get(key);\n      this.getMetadata(key).mergeIn(metadataLogic);\n    }\n  }\n}\nclass AbstractLogicNodeBuilder {\n  depth;\n  constructor(depth) {\n    this.depth = depth;\n  }\n  build() {\n    return new LeafLogicNode(this, [], 0);\n  }\n}\nclass LogicNodeBuilder extends AbstractLogicNodeBuilder {\n  constructor(depth) {\n    super(depth);\n  }\n  current;\n  all = [];\n  addHiddenRule(logic) {\n    this.getCurrent().addHiddenRule(logic);\n  }\n  addDisabledReasonRule(logic) {\n    this.getCurrent().addDisabledReasonRule(logic);\n  }\n  addReadonlyRule(logic) {\n    this.getCurrent().addReadonlyRule(logic);\n  }\n  addSyncErrorRule(logic) {\n    this.getCurrent().addSyncErrorRule(logic);\n  }\n  addSyncTreeErrorRule(logic) {\n    this.getCurrent().addSyncTreeErrorRule(logic);\n  }\n  addAsyncErrorRule(logic) {\n    this.getCurrent().addAsyncErrorRule(logic);\n  }\n  addMetadataRule(key, logic) {\n    this.getCurrent().addMetadataRule(key, logic);\n  }\n  getChild(key) {\n    if (key === DYNAMIC) {\n      const children = this.getCurrent().children;\n      if (children.size > (children.has(DYNAMIC) ? 1 : 0)) {\n        this.current = undefined;\n      }\n    }\n    return this.getCurrent().getChild(key);\n  }\n  hasLogic(builder) {\n    if (this === builder) {\n      return true;\n    }\n    return this.all.some(({\n      builder: subBuilder\n    }) => subBuilder.hasLogic(builder));\n  }\n  mergeIn(other, predicate) {\n    if (predicate) {\n      this.all.push({\n        builder: other,\n        predicate: {\n          fn: setBoundPathDepthForResolution(predicate.fn, this.depth),\n          path: predicate.path\n        }\n      });\n    } else {\n      this.all.push({\n        builder: other\n      });\n    }\n    this.current = undefined;\n  }\n  getCurrent() {\n    if (this.current === undefined) {\n      this.current = new NonMergeableLogicNodeBuilder(this.depth);\n      this.all.push({\n        builder: this.current\n      });\n    }\n    return this.current;\n  }\n  static newRoot() {\n    return new LogicNodeBuilder(0);\n  }\n}\nclass NonMergeableLogicNodeBuilder extends AbstractLogicNodeBuilder {\n  logic = /*#__PURE__*/new LogicContainer([]);\n  children = /*#__PURE__*/new Map();\n  constructor(depth) {\n    super(depth);\n  }\n  addHiddenRule(logic) {\n    this.logic.hidden.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addDisabledReasonRule(logic) {\n    this.logic.disabledReasons.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addReadonlyRule(logic) {\n    this.logic.readonly.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addSyncErrorRule(logic) {\n    this.logic.syncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addSyncTreeErrorRule(logic) {\n    this.logic.syncTreeErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addAsyncErrorRule(logic) {\n    this.logic.asyncErrors.push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  addMetadataRule(key, logic) {\n    this.logic.getMetadata(key).push(setBoundPathDepthForResolution(logic, this.depth));\n  }\n  getChild(key) {\n    if (!this.children.has(key)) {\n      this.children.set(key, new LogicNodeBuilder(this.depth + 1));\n    }\n    return this.children.get(key);\n  }\n  hasLogic(builder) {\n    return this === builder;\n  }\n}\nclass LeafLogicNode {\n  builder;\n  predicates;\n  depth;\n  logic;\n  constructor(builder, predicates, depth) {\n    this.builder = builder;\n    this.predicates = predicates;\n    this.depth = depth;\n    this.logic = builder ? createLogic(builder, predicates, depth) : new LogicContainer([]);\n  }\n  getChild(key) {\n    const childBuilders = this.builder ? getAllChildBuilders(this.builder, key) : [];\n    if (childBuilders.length === 0) {\n      return new LeafLogicNode(undefined, [], this.depth + 1);\n    } else if (childBuilders.length === 1) {\n      const {\n        builder,\n        predicates\n      } = childBuilders[0];\n      return new LeafLogicNode(builder, [...this.predicates, ...predicates.map(p => bindLevel(p, this.depth))], this.depth + 1);\n    } else {\n      const builtNodes = childBuilders.map(({\n        builder,\n        predicates\n      }) => new LeafLogicNode(builder, [...this.predicates, ...predicates.map(p => bindLevel(p, this.depth))], this.depth + 1));\n      return new CompositeLogicNode(builtNodes);\n    }\n  }\n  hasLogic(builder) {\n    return this.builder?.hasLogic(builder) ?? false;\n  }\n}\nclass CompositeLogicNode {\n  all;\n  logic;\n  constructor(all) {\n    this.all = all;\n    this.logic = new LogicContainer([]);\n    for (const node of all) {\n      this.logic.mergeIn(node.logic);\n    }\n  }\n  getChild(key) {\n    return new CompositeLogicNode(this.all.flatMap(child => child.getChild(key)));\n  }\n  hasLogic(builder) {\n    return this.all.some(node => node.hasLogic(builder));\n  }\n}\nfunction getAllChildBuilders(builder, key) {\n  if (builder instanceof LogicNodeBuilder) {\n    return builder.all.flatMap(({\n      builder,\n      predicate\n    }) => {\n      const children = getAllChildBuilders(builder, key);\n      if (predicate) {\n        return children.map(({\n          builder,\n          predicates\n        }) => ({\n          builder,\n          predicates: [...predicates, predicate]\n        }));\n      }\n      return children;\n    });\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    return [...(key !== DYNAMIC && builder.children.has(DYNAMIC) ? [{\n      builder: builder.getChild(DYNAMIC),\n      predicates: []\n    }] : []), ...(builder.children.has(key) ? [{\n      builder: builder.getChild(key),\n      predicates: []\n    }] : [])];\n  } else {\n    throw new Error('Unknown LogicNodeBuilder type');\n  }\n}\nfunction createLogic(builder, predicates, depth) {\n  const logic = new LogicContainer(predicates);\n  if (builder instanceof LogicNodeBuilder) {\n    const builtNodes = builder.all.map(({\n      builder,\n      predicate\n    }) => new LeafLogicNode(builder, predicate ? [...predicates, bindLevel(predicate, depth)] : predicates, depth));\n    for (const node of builtNodes) {\n      logic.mergeIn(node.logic);\n    }\n  } else if (builder instanceof NonMergeableLogicNodeBuilder) {\n    logic.mergeIn(builder.logic);\n  } else {\n    throw new Error('Unknown LogicNodeBuilder type');\n  }\n  return logic;\n}\nfunction bindLevel(predicate, depth) {\n  return {\n    ...predicate,\n    depth: depth\n  };\n}\nconst PATH = /*#__PURE__*/Symbol('PATH');\nclass FieldPathNode {\n  keys;\n  parent;\n  keyInParent;\n  root;\n  children = /*#__PURE__*/new Map();\n  fieldPathProxy = /*#__PURE__*/new Proxy(this, FIELD_PATH_PROXY_HANDLER);\n  logicBuilder;\n  constructor(keys, root, parent, keyInParent) {\n    this.keys = keys;\n    this.parent = parent;\n    this.keyInParent = keyInParent;\n    this.root = root ?? this;\n    if (!parent) {\n      this.logicBuilder = LogicNodeBuilder.newRoot();\n    }\n  }\n  get builder() {\n    if (this.logicBuilder) {\n      return this.logicBuilder;\n    }\n    return this.parent.builder.getChild(this.keyInParent);\n  }\n  getChild(key) {\n    if (!this.children.has(key)) {\n      this.children.set(key, new FieldPathNode([...this.keys, key], this.root, this, key));\n    }\n    return this.children.get(key);\n  }\n  mergeIn(other, predicate) {\n    const path = other.compile();\n    this.builder.mergeIn(path.builder, predicate);\n  }\n  static unwrapFieldPath(formPath) {\n    return formPath[PATH];\n  }\n  static newRoot() {\n    return new FieldPathNode([], undefined, undefined, undefined);\n  }\n}\nconst FIELD_PATH_PROXY_HANDLER = {\n  get(node, property) {\n    if (property === PATH) {\n      return node;\n    }\n    return node.getChild(property).fieldPathProxy;\n  }\n};\nlet currentCompilingNode = undefined;\nconst compiledSchemas = /*#__PURE__*/new Map();\nclass SchemaImpl {\n  schemaFn;\n  constructor(schemaFn) {\n    this.schemaFn = schemaFn;\n  }\n  compile() {\n    if (compiledSchemas.has(this)) {\n      return compiledSchemas.get(this);\n    }\n    const path = FieldPathNode.newRoot();\n    compiledSchemas.set(this, path);\n    let prevCompilingNode = currentCompilingNode;\n    try {\n      currentCompilingNode = path;\n      this.schemaFn(path.fieldPathProxy);\n    } finally {\n      currentCompilingNode = prevCompilingNode;\n    }\n    return path;\n  }\n  static create(schema) {\n    if (schema instanceof SchemaImpl) {\n      return schema;\n    }\n    return new SchemaImpl(schema);\n  }\n  static rootCompile(schema) {\n    try {\n      compiledSchemas.clear();\n      if (schema === undefined) {\n        return FieldPathNode.newRoot();\n      }\n      if (schema instanceof SchemaImpl) {\n        return schema.compile();\n      }\n      return new SchemaImpl(schema).compile();\n    } finally {\n      compiledSchemas.clear();\n    }\n  }\n}\nfunction isSchemaOrSchemaFn(value) {\n  return value instanceof SchemaImpl || typeof value === 'function';\n}\nfunction assertPathIsCurrent(path) {\n  if (currentCompilingNode !== FieldPathNode.unwrapFieldPath(path).root) {\n    throw new Error(`A FieldPath can only be used directly within the Schema that owns it,` + ` **not** outside of it or within a sub-schema.`);\n  }\n}\nfunction metadata(path, key, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addMetadataRule(key, logic);\n  return key;\n}\nconst MetadataReducer = {\n  list() {\n    return {\n      reduce: (acc, item) => item === undefined ? acc : [...acc, item],\n      getInitial: () => []\n    };\n  },\n  min() {\n    return {\n      reduce: (acc, item) => {\n        if (acc === undefined || item === undefined) {\n          return acc ?? item;\n        }\n        return Math.min(acc, item);\n      },\n      getInitial: () => undefined\n    };\n  },\n  max() {\n    return {\n      reduce: (prev, next) => {\n        if (prev === undefined || next === undefined) {\n          return prev ?? next;\n        }\n        return Math.max(prev, next);\n      },\n      getInitial: () => undefined\n    };\n  },\n  or() {\n    return {\n      reduce: (prev, next) => prev || next,\n      getInitial: () => false\n    };\n  },\n  and() {\n    return {\n      reduce: (prev, next) => prev && next,\n      getInitial: () => true\n    };\n  },\n  override\n};\nfunction override(getInitial) {\n  return {\n    reduce: (_, item) => item,\n    getInitial: () => getInitial?.()\n  };\n}\nclass MetadataKey {\n  reducer;\n  create;\n  brand;\n  constructor(reducer, create) {\n    this.reducer = reducer;\n    this.create = create;\n  }\n}\nfunction createMetadataKey(reducer) {\n  return new MetadataKey(reducer ?? MetadataReducer.override());\n}\nfunction createManagedMetadataKey(create, reducer) {\n  return new MetadataKey(reducer ?? MetadataReducer.override(), create);\n}\nconst REQUIRED = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.or());\nconst MIN = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.max());\nconst MAX = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.min());\nconst MIN_LENGTH = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.max());\nconst MAX_LENGTH = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.min());\nconst PATTERN = /*#__PURE__*/createMetadataKey(/*#__PURE__*/MetadataReducer.list());\nfunction calculateValidationSelfStatus(state) {\n  if (state.errors().length > 0) {\n    return 'invalid';\n  }\n  if (state.pending()) {\n    return 'unknown';\n  }\n  return 'valid';\n}\nclass FieldValidationState {\n  node;\n  constructor(node) {\n    this.node = node;\n  }\n  rawSyncTreeErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return [...this.node.logicNode.logic.syncTreeErrors.compute(this.node.context), ...(this.node.structure.parent?.validationState.rawSyncTreeErrors() ?? [])];\n  }, ...(ngDevMode ? [{\n    debugName: \"rawSyncTreeErrors\"\n  }] : []));\n  syncErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return [...this.node.logicNode.logic.syncErrors.compute(this.node.context), ...this.syncTreeErrors(), ...normalizeErrors(this.node.submitState.serverErrors())];\n  }, ...(ngDevMode ? [{\n    debugName: \"syncErrors\"\n  }] : []));\n  syncValid = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return true;\n    }\n    return this.node.structure.reduceChildren(this.syncErrors().length === 0, (child, value) => value && child.validationState.syncValid(), shortCircuitFalse);\n  }, ...(ngDevMode ? [{\n    debugName: \"syncValid\"\n  }] : []));\n  syncTreeErrors = /*#__PURE__*/computed(() => this.rawSyncTreeErrors().filter(err => err.field === this.node.fieldProxy), ...(ngDevMode ? [{\n    debugName: \"syncTreeErrors\"\n  }] : []));\n  rawAsyncErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return [...this.node.logicNode.logic.asyncErrors.compute(this.node.context), ...(this.node.structure.parent?.validationState.rawAsyncErrors() ?? [])];\n  }, ...(ngDevMode ? [{\n    debugName: \"rawAsyncErrors\"\n  }] : []));\n  asyncErrors = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return [];\n    }\n    return this.rawAsyncErrors().filter(err => err === 'pending' || err.field === this.node.fieldProxy);\n  }, ...(ngDevMode ? [{\n    debugName: \"asyncErrors\"\n  }] : []));\n  errors = /*#__PURE__*/computed(() => [...this.syncErrors(), ...this.asyncErrors().filter(err => err !== 'pending')], ...(ngDevMode ? [{\n    debugName: \"errors\"\n  }] : []));\n  errorSummary = /*#__PURE__*/computed(() => this.node.structure.reduceChildren(this.errors(), (child, result) => [...result, ...child.errorSummary()]), ...(ngDevMode ? [{\n    debugName: \"errorSummary\"\n  }] : []));\n  pending = /*#__PURE__*/computed(() => this.node.structure.reduceChildren(this.asyncErrors().includes('pending'), (child, value) => value || child.validationState.asyncErrors().includes('pending')), ...(ngDevMode ? [{\n    debugName: \"pending\"\n  }] : []));\n  status = /*#__PURE__*/computed(() => {\n    if (this.shouldSkipValidation()) {\n      return 'valid';\n    }\n    let ownStatus = calculateValidationSelfStatus(this);\n    return this.node.structure.reduceChildren(ownStatus, (child, value) => {\n      if (value === 'invalid' || child.validationState.status() === 'invalid') {\n        return 'invalid';\n      } else if (value === 'unknown' || child.validationState.status() === 'unknown') {\n        return 'unknown';\n      }\n      return 'valid';\n    }, v => v === 'invalid');\n  }, ...(ngDevMode ? [{\n    debugName: \"status\"\n  }] : []));\n  valid = /*#__PURE__*/computed(() => this.status() === 'valid', ...(ngDevMode ? [{\n    debugName: \"valid\"\n  }] : []));\n  invalid = /*#__PURE__*/computed(() => this.status() === 'invalid', ...(ngDevMode ? [{\n    debugName: \"invalid\"\n  }] : []));\n  shouldSkipValidation = /*#__PURE__*/computed(() => this.node.hidden() || this.node.disabled() || this.node.readonly(), ...(ngDevMode ? [{\n    debugName: \"shouldSkipValidation\"\n  }] : []));\n}\nfunction normalizeErrors(error) {\n  if (error === undefined) {\n    return [];\n  }\n  if (isArray(error)) {\n    return error;\n  }\n  return [error];\n}\nfunction addDefaultField(errors, field) {\n  if (isArray(errors)) {\n    for (const error of errors) {\n      error.field ??= field;\n    }\n  } else if (errors) {\n    errors.field ??= field;\n  }\n  return errors;\n}\nconst DEBOUNCER = /*#__PURE__*/createMetadataKey();\nclass FieldNodeContext {\n  node;\n  cache = /*#__PURE__*/new WeakMap();\n  constructor(node) {\n    this.node = node;\n  }\n  resolve(target) {\n    if (!this.cache.has(target)) {\n      const resolver = computed(() => {\n        const targetPathNode = FieldPathNode.unwrapFieldPath(target);\n        let field = this.node;\n        let stepsRemaining = getBoundPathDepth();\n        while (stepsRemaining > 0 || !field.structure.logic.hasLogic(targetPathNode.root.builder)) {\n          stepsRemaining--;\n          field = field.structure.parent;\n          if (field === undefined) {\n            throw new Error('Path is not part of this field tree.');\n          }\n        }\n        for (let key of targetPathNode.keys) {\n          field = field.structure.getChild(key);\n          if (field === undefined) {\n            throw new Error(`Cannot resolve path .${targetPathNode.keys.join('.')} relative to field ${['<root>', ...this.node.structure.pathKeys()].join('.')}.`);\n          }\n        }\n        return field.fieldProxy;\n      }, ...(ngDevMode ? [{\n        debugName: \"resolver\"\n      }] : []));\n      this.cache.set(target, resolver);\n    }\n    return this.cache.get(target)();\n  }\n  get field() {\n    return this.node.fieldProxy;\n  }\n  get state() {\n    return this.node;\n  }\n  get value() {\n    return this.node.structure.value;\n  }\n  get key() {\n    return this.node.structure.keyInParent;\n  }\n  get pathKeys() {\n    return this.node.structure.pathKeys;\n  }\n  index = /*#__PURE__*/computed(() => {\n    const key = this.key();\n    if (!isArray(untracked(this.node.structure.parent.value))) {\n      throw new Error(`RuntimeError: cannot access index, parent field is not an array`);\n    }\n    return Number(key);\n  }, ...(ngDevMode ? [{\n    debugName: \"index\"\n  }] : []));\n  fieldTreeOf = p => this.resolve(p);\n  stateOf = p => this.resolve(p)();\n  valueOf = p => {\n    const result = this.resolve(p)().value();\n    if (result instanceof AbstractControl) {\n      throw new Error(`Tried to read an 'AbstractControl' value form a 'form()'. Did you mean to use 'compatForm()' instead?`);\n    }\n    return result;\n  };\n}\nclass FieldMetadataState {\n  node;\n  metadata = /*#__PURE__*/new Map();\n  constructor(node) {\n    this.node = node;\n    for (const key of this.node.logicNode.logic.getMetadataKeys()) {\n      if (key.create) {\n        const logic = this.node.logicNode.logic.getMetadata(key);\n        const result = untracked(() => runInInjectionContext(this.node.structure.injector, () => key.create(computed(() => logic.compute(this.node.context)))));\n        this.metadata.set(key, result);\n      }\n    }\n  }\n  get(key) {\n    if (this.has(key)) {\n      if (!this.metadata.has(key)) {\n        if (key.create) {\n          throw Error('Managed metadata cannot be created lazily');\n        }\n        const logic = this.node.logicNode.logic.getMetadata(key);\n        this.metadata.set(key, computed(() => logic.compute(this.node.context)));\n      }\n    }\n    return this.metadata.get(key);\n  }\n  has(key) {\n    return this.node.logicNode.logic.hasMetadata(key);\n  }\n}\nconst FIELD_PROXY_HANDLER = {\n  get(getTgt, p, receiver) {\n    const tgt = getTgt();\n    const child = tgt.structure.getChild(p);\n    if (child !== undefined) {\n      return child.fieldProxy;\n    }\n    const value = untracked(tgt.value);\n    if (isArray(value)) {\n      if (p === 'length') {\n        return tgt.value().length;\n      }\n      if (p === Symbol.iterator) {\n        return () => {\n          tgt.value();\n          return Array.prototype[Symbol.iterator].apply(tgt.fieldProxy);\n        };\n      }\n    }\n    if (isObject(value)) {\n      if (p === Symbol.iterator) {\n        return function* () {\n          for (const key in receiver) {\n            yield [key, receiver[key]];\n          }\n        };\n      }\n    }\n    return undefined;\n  },\n  getOwnPropertyDescriptor(getTgt, prop) {\n    const value = untracked(getTgt().value);\n    const desc = Reflect.getOwnPropertyDescriptor(value, prop);\n    if (desc && !desc.configurable) {\n      desc.configurable = true;\n    }\n    return desc;\n  },\n  ownKeys(getTgt) {\n    const value = untracked(getTgt().value);\n    return typeof value === 'object' && value !== null ? Reflect.ownKeys(value) : [];\n  }\n};\nfunction deepSignal(source, prop) {\n  const read = computed(() => source()[prop()]);\n  read[SIGNAL] = source[SIGNAL];\n  read.set = value => {\n    source.update(current => valueForWrite(current, value, prop()));\n  };\n  read.update = fn => {\n    read.set(fn(untracked(read)));\n  };\n  read.asReadonly = () => read;\n  return read;\n}\nfunction valueForWrite(sourceValue, newPropValue, prop) {\n  if (isArray(sourceValue)) {\n    const newValue = [...sourceValue];\n    newValue[prop] = newPropValue;\n    return newValue;\n  } else {\n    return {\n      ...sourceValue,\n      [prop]: newPropValue\n    };\n  }\n}\nclass FieldNodeStructure {\n  logic;\n  node;\n  createChildNode;\n  identitySymbol = /*#__PURE__*/Symbol();\n  _injector = undefined;\n  get injector() {\n    this._injector ??= Injector.create({\n      providers: [],\n      parent: this.fieldManager.injector\n    });\n    return this._injector;\n  }\n  constructor(logic, node, createChildNode) {\n    this.logic = logic;\n    this.node = node;\n    this.createChildNode = createChildNode;\n  }\n  children() {\n    const map = this.childrenMap();\n    if (map === undefined) {\n      return [];\n    }\n    return Array.from(map.byPropertyKey.values()).map(child => untracked(child.reader));\n  }\n  getChild(key) {\n    const strKey = key.toString();\n    let reader = untracked(this.childrenMap)?.byPropertyKey.get(strKey)?.reader;\n    if (!reader) {\n      reader = this.createReader(strKey);\n    }\n    return reader();\n  }\n  reduceChildren(initialValue, fn, shortCircuit) {\n    const map = this.childrenMap();\n    if (!map) {\n      return initialValue;\n    }\n    let value = initialValue;\n    for (const child of map.byPropertyKey.values()) {\n      if (shortCircuit?.(value)) {\n        break;\n      }\n      value = fn(untracked(child.reader), value);\n    }\n    return value;\n  }\n  destroy() {\n    this.injector.destroy();\n  }\n  createKeyInParent(options, identityInParent, initialKeyInParent) {\n    if (options.kind === 'root') {\n      return ROOT_KEY_IN_PARENT;\n    }\n    if (identityInParent === undefined) {\n      const key = initialKeyInParent;\n      return computed(() => {\n        if (this.parent.structure.getChild(key) !== this.node) {\n          throw new Error(`RuntimeError: orphan field, looking for property '${key}' of ${getDebugName(this.parent)}`);\n        }\n        return key;\n      });\n    } else {\n      let lastKnownKey = initialKeyInParent;\n      return computed(() => {\n        const parentValue = this.parent.structure.value();\n        if (!isArray(parentValue)) {\n          throw new Error(`RuntimeError: orphan field, expected ${getDebugName(this.parent)} to be an array`);\n        }\n        const data = parentValue[lastKnownKey];\n        if (isObject(data) && data.hasOwnProperty(this.parent.structure.identitySymbol) && data[this.parent.structure.identitySymbol] === identityInParent) {\n          return lastKnownKey;\n        }\n        for (let i = 0; i < parentValue.length; i++) {\n          const data = parentValue[i];\n          if (isObject(data) && data.hasOwnProperty(this.parent.structure.identitySymbol) && data[this.parent.structure.identitySymbol] === identityInParent) {\n            return lastKnownKey = i.toString();\n          }\n        }\n        throw new Error(`RuntimeError: orphan field, can't find element in array ${getDebugName(this.parent)}`);\n      });\n    }\n  }\n  createChildrenMap() {\n    return linkedSignal({\n      source: this.value,\n      computation: (value, previous) => {\n        if (!isObject(value)) {\n          return undefined;\n        }\n        const prevData = previous?.value ?? {\n          byPropertyKey: new Map()\n        };\n        let data;\n        const parentIsArray = isArray(value);\n        if (prevData !== undefined) {\n          if (parentIsArray) {\n            data = maybeRemoveStaleArrayFields(prevData, value, this.identitySymbol);\n          } else {\n            data = maybeRemoveStaleObjectFields(prevData, value);\n          }\n        }\n        for (const key of Object.keys(value)) {\n          let trackingKey = undefined;\n          const childValue = value[key];\n          if (childValue === undefined) {\n            if (prevData.byPropertyKey.has(key)) {\n              data ??= {\n                ...prevData\n              };\n              data.byPropertyKey.delete(key);\n            }\n            continue;\n          }\n          if (parentIsArray && isObject(childValue) && !isArray(childValue)) {\n            trackingKey = childValue[this.identitySymbol] ??= Symbol(ngDevMode ? `id:${globalId++}` : '');\n          }\n          let childNode;\n          if (trackingKey) {\n            if (!prevData.byTrackingKey?.has(trackingKey)) {\n              data ??= {\n                ...prevData\n              };\n              data.byTrackingKey ??= new Map();\n              data.byTrackingKey.set(trackingKey, this.createChildNode(key, trackingKey, parentIsArray));\n            }\n            childNode = (data ?? prevData).byTrackingKey.get(trackingKey);\n          }\n          const child = prevData.byPropertyKey.get(key);\n          if (child === undefined) {\n            data ??= {\n              ...prevData\n            };\n            data.byPropertyKey.set(key, {\n              reader: this.createReader(key),\n              node: childNode ?? this.createChildNode(key, trackingKey, parentIsArray)\n            });\n          } else if (childNode && childNode !== child.node) {\n            data ??= {\n              ...prevData\n            };\n            child.node = childNode;\n          }\n        }\n        return data ?? prevData;\n      }\n    });\n  }\n  createReader(key) {\n    return computed(() => this.childrenMap()?.byPropertyKey.get(key)?.node);\n  }\n}\nclass RootFieldNodeStructure extends FieldNodeStructure {\n  fieldManager;\n  value;\n  get parent() {\n    return undefined;\n  }\n  get root() {\n    return this.node;\n  }\n  get pathKeys() {\n    return ROOT_PATH_KEYS;\n  }\n  get keyInParent() {\n    return ROOT_KEY_IN_PARENT;\n  }\n  childrenMap;\n  constructor(node, logic, fieldManager, value, createChildNode) {\n    super(logic, node, createChildNode);\n    this.fieldManager = fieldManager;\n    this.value = value;\n    this.childrenMap = this.createChildrenMap();\n  }\n}\nclass ChildFieldNodeStructure extends FieldNodeStructure {\n  logic;\n  parent;\n  root;\n  pathKeys;\n  keyInParent;\n  value;\n  childrenMap;\n  get fieldManager() {\n    return this.root.structure.fieldManager;\n  }\n  constructor(node, logic, parent, identityInParent, initialKeyInParent, createChildNode) {\n    super(logic, node, createChildNode);\n    this.logic = logic;\n    this.parent = parent;\n    this.root = this.parent.structure.root;\n    this.keyInParent = this.createKeyInParent({\n      kind: 'child',\n      parent,\n      pathNode: undefined,\n      logic,\n      initialKeyInParent,\n      identityInParent,\n      fieldAdapter: undefined\n    }, identityInParent, initialKeyInParent);\n    this.pathKeys = computed(() => [...parent.structure.pathKeys(), this.keyInParent()], ...(ngDevMode ? [{\n      debugName: \"pathKeys\"\n    }] : []));\n    this.value = deepSignal(this.parent.structure.value, this.keyInParent);\n    this.childrenMap = this.createChildrenMap();\n    this.fieldManager.structures.add(this);\n  }\n}\nlet globalId = 0;\nconst ROOT_PATH_KEYS = /*#__PURE__*/computed(() => [], ...(ngDevMode ? [{\n  debugName: \"ROOT_PATH_KEYS\"\n}] : []));\nconst ROOT_KEY_IN_PARENT = /*#__PURE__*/computed(() => {\n  throw new Error(`RuntimeError: the top-level field in the form has no parent`);\n}, ...(ngDevMode ? [{\n  debugName: \"ROOT_KEY_IN_PARENT\"\n}] : []));\nfunction getDebugName(node) {\n  return `<root>.${node.structure.pathKeys().join('.')}`;\n}\nfunction maybeRemoveStaleArrayFields(prevData, value, identitySymbol) {\n  let data;\n  const oldKeys = new Set(prevData.byPropertyKey.keys());\n  const oldTracking = new Set(prevData.byTrackingKey?.keys());\n  for (let i = 0; i < value.length; i++) {\n    const childValue = value[i];\n    oldKeys.delete(i.toString());\n    if (isObject(childValue) && childValue.hasOwnProperty(identitySymbol)) {\n      oldTracking.delete(childValue[identitySymbol]);\n    }\n  }\n  if (oldKeys.size > 0) {\n    data ??= {\n      ...prevData\n    };\n    for (const key of oldKeys) {\n      data.byPropertyKey.delete(key);\n    }\n  }\n  if (oldTracking.size > 0) {\n    data ??= {\n      ...prevData\n    };\n    for (const id of oldTracking) {\n      data.byTrackingKey?.delete(id);\n    }\n  }\n  return data;\n}\nfunction maybeRemoveStaleObjectFields(prevData, value) {\n  let data;\n  for (const key of prevData.byPropertyKey.keys()) {\n    if (!value.hasOwnProperty(key)) {\n      data ??= {\n        ...prevData\n      };\n      data.byPropertyKey.delete(key);\n    }\n  }\n  return data;\n}\nclass FieldSubmitState {\n  node;\n  selfSubmitting = /*#__PURE__*/signal(false, ...(ngDevMode ? [{\n    debugName: \"selfSubmitting\"\n  }] : []));\n  serverErrors;\n  constructor(node) {\n    this.node = node;\n    this.serverErrors = linkedSignal({\n      ...(ngDevMode ? {\n        debugName: \"serverErrors\"\n      } : {}),\n      source: this.node.structure.value,\n      computation: () => []\n    });\n  }\n  submitting = /*#__PURE__*/computed(() => {\n    return this.selfSubmitting() || (this.node.structure.parent?.submitting() ?? false);\n  }, ...(ngDevMode ? [{\n    debugName: \"submitting\"\n  }] : []));\n}\nclass FieldNode {\n  structure;\n  validationState;\n  metadataState;\n  nodeState;\n  submitState;\n  fieldAdapter;\n  _context = undefined;\n  get context() {\n    return this._context ??= new FieldNodeContext(this);\n  }\n  fieldProxy = /*#__PURE__*/new Proxy(() => this, FIELD_PROXY_HANDLER);\n  pathNode;\n  constructor(options) {\n    this.pathNode = options.pathNode;\n    this.fieldAdapter = options.fieldAdapter;\n    this.structure = this.fieldAdapter.createStructure(this, options);\n    this.validationState = this.fieldAdapter.createValidationState(this, options);\n    this.nodeState = this.fieldAdapter.createNodeState(this, options);\n    this.metadataState = new FieldMetadataState(this);\n    this.submitState = new FieldSubmitState(this);\n  }\n  pendingSync = /*#__PURE__*/linkedSignal({\n    ...(ngDevMode ? {\n      debugName: \"pendingSync\"\n    } : {}),\n    source: () => this.value(),\n    computation: (_source, previous) => {\n      previous?.value?.abort();\n      return undefined;\n    }\n  });\n  get logicNode() {\n    return this.structure.logic;\n  }\n  get value() {\n    return this.structure.value;\n  }\n  _controlValue = /*#__PURE__*/linkedSignal(() => this.value(), ...(ngDevMode ? [{\n    debugName: \"_controlValue\"\n  }] : []));\n  get controlValue() {\n    return this._controlValue.asReadonly();\n  }\n  get keyInParent() {\n    return this.structure.keyInParent;\n  }\n  get errors() {\n    return this.validationState.errors;\n  }\n  get errorSummary() {\n    return this.validationState.errorSummary;\n  }\n  get pending() {\n    return this.validationState.pending;\n  }\n  get valid() {\n    return this.validationState.valid;\n  }\n  get invalid() {\n    return this.validationState.invalid;\n  }\n  get dirty() {\n    return this.nodeState.dirty;\n  }\n  get touched() {\n    return this.nodeState.touched;\n  }\n  get disabled() {\n    return this.nodeState.disabled;\n  }\n  get disabledReasons() {\n    return this.nodeState.disabledReasons;\n  }\n  get hidden() {\n    return this.nodeState.hidden;\n  }\n  get readonly() {\n    return this.nodeState.readonly;\n  }\n  get fieldBindings() {\n    return this.nodeState.fieldBindings;\n  }\n  get submitting() {\n    return this.submitState.submitting;\n  }\n  get name() {\n    return this.nodeState.name;\n  }\n  get max() {\n    return this.metadata(MAX);\n  }\n  get maxLength() {\n    return this.metadata(MAX_LENGTH);\n  }\n  get min() {\n    return this.metadata(MIN);\n  }\n  get minLength() {\n    return this.metadata(MIN_LENGTH);\n  }\n  get pattern() {\n    return this.metadata(PATTERN) ?? EMPTY;\n  }\n  get required() {\n    return this.metadata(REQUIRED) ?? FALSE;\n  }\n  metadata(key) {\n    return this.metadataState.get(key);\n  }\n  hasMetadata(key) {\n    return this.metadataState.has(key);\n  }\n  markAsTouched() {\n    this.nodeState.markAsTouched();\n    this.pendingSync()?.abort();\n    this.sync();\n  }\n  markAsDirty() {\n    this.nodeState.markAsDirty();\n  }\n  reset(value) {\n    untracked(() => this._reset(value));\n  }\n  _reset(value) {\n    if (value !== undefined) {\n      this.value.set(value);\n    }\n    this.nodeState.markAsUntouched();\n    this.nodeState.markAsPristine();\n    for (const child of this.structure.children()) {\n      child._reset();\n    }\n  }\n  setControlValue(newValue) {\n    this._controlValue.set(newValue);\n    this.markAsDirty();\n    this.debounceSync();\n  }\n  sync() {\n    this.value.set(this.controlValue());\n  }\n  async debounceSync() {\n    this.pendingSync()?.abort();\n    const debouncer = this.nodeState.debouncer();\n    if (debouncer) {\n      const controller = new AbortController();\n      const promise = debouncer(controller.signal);\n      if (promise) {\n        this.pendingSync.set(controller);\n        await promise;\n        if (controller.signal.aborted) {\n          return;\n        }\n      }\n    }\n    this.sync();\n  }\n  static newRoot(fieldManager, value, pathNode, adapter) {\n    return adapter.newRoot(fieldManager, value, pathNode, adapter);\n  }\n  createStructure(options) {\n    return options.kind === 'root' ? new RootFieldNodeStructure(this, options.logic, options.fieldManager, options.value, this.newChild.bind(this)) : new ChildFieldNodeStructure(this, options.logic, options.parent, options.identityInParent, options.initialKeyInParent, this.newChild.bind(this));\n  }\n  newChild(key, trackingId, isArray) {\n    let childPath;\n    let childLogic;\n    if (isArray) {\n      childPath = this.pathNode.getChild(DYNAMIC);\n      childLogic = this.structure.logic.getChild(DYNAMIC);\n    } else {\n      childPath = this.pathNode.getChild(key);\n      childLogic = this.structure.logic.getChild(key);\n    }\n    return this.fieldAdapter.newChild({\n      kind: 'child',\n      parent: this,\n      pathNode: childPath,\n      logic: childLogic,\n      initialKeyInParent: key,\n      identityInParent: trackingId,\n      fieldAdapter: this.fieldAdapter\n    });\n  }\n}\nconst EMPTY = /*#__PURE__*/computed(() => [], ...(ngDevMode ? [{\n  debugName: \"EMPTY\"\n}] : []));\nconst FALSE = /*#__PURE__*/computed(() => false, ...(ngDevMode ? [{\n  debugName: \"FALSE\"\n}] : []));\nclass FieldNodeState {\n  node;\n  selfTouched = /*#__PURE__*/signal(false, ...(ngDevMode ? [{\n    debugName: \"selfTouched\"\n  }] : []));\n  selfDirty = /*#__PURE__*/signal(false, ...(ngDevMode ? [{\n    debugName: \"selfDirty\"\n  }] : []));\n  markAsTouched() {\n    this.selfTouched.set(true);\n  }\n  markAsDirty() {\n    this.selfDirty.set(true);\n  }\n  markAsPristine() {\n    this.selfDirty.set(false);\n  }\n  markAsUntouched() {\n    this.selfTouched.set(false);\n  }\n  fieldBindings = /*#__PURE__*/signal([], ...(ngDevMode ? [{\n    debugName: \"fieldBindings\"\n  }] : []));\n  constructor(node) {\n    this.node = node;\n  }\n  dirty = /*#__PURE__*/computed(() => {\n    const selfDirtyValue = this.selfDirty() && !this.isNonInteractive();\n    return this.node.structure.reduceChildren(selfDirtyValue, (child, value) => value || child.nodeState.dirty(), shortCircuitTrue);\n  }, ...(ngDevMode ? [{\n    debugName: \"dirty\"\n  }] : []));\n  touched = /*#__PURE__*/computed(() => {\n    const selfTouchedValue = this.selfTouched() && !this.isNonInteractive();\n    return this.node.structure.reduceChildren(selfTouchedValue, (child, value) => value || child.nodeState.touched(), shortCircuitTrue);\n  }, ...(ngDevMode ? [{\n    debugName: \"touched\"\n  }] : []));\n  disabledReasons = /*#__PURE__*/computed(() => [...(this.node.structure.parent?.nodeState.disabledReasons() ?? []), ...this.node.logicNode.logic.disabledReasons.compute(this.node.context)], ...(ngDevMode ? [{\n    debugName: \"disabledReasons\"\n  }] : []));\n  disabled = /*#__PURE__*/computed(() => !!this.disabledReasons().length, ...(ngDevMode ? [{\n    debugName: \"disabled\"\n  }] : []));\n  readonly = /*#__PURE__*/computed(() => (this.node.structure.parent?.nodeState.readonly() || this.node.logicNode.logic.readonly.compute(this.node.context)) ?? false, ...(ngDevMode ? [{\n    debugName: \"readonly\"\n  }] : []));\n  hidden = /*#__PURE__*/computed(() => (this.node.structure.parent?.nodeState.hidden() || this.node.logicNode.logic.hidden.compute(this.node.context)) ?? false, ...(ngDevMode ? [{\n    debugName: \"hidden\"\n  }] : []));\n  name = /*#__PURE__*/computed(() => {\n    const parent = this.node.structure.parent;\n    if (!parent) {\n      return this.node.structure.fieldManager.rootName;\n    }\n    return `${parent.name()}.${this.node.structure.keyInParent()}`;\n  }, ...(ngDevMode ? [{\n    debugName: \"name\"\n  }] : []));\n  debouncer = /*#__PURE__*/computed(() => {\n    if (this.node.logicNode.logic.hasMetadata(DEBOUNCER)) {\n      const debouncerLogic = this.node.logicNode.logic.getMetadata(DEBOUNCER);\n      const debouncer = debouncerLogic.compute(this.node.context);\n      if (debouncer) {\n        return signal => debouncer(this.node.context, signal);\n      }\n    }\n    return this.node.structure.parent?.nodeState.debouncer?.();\n  }, ...(ngDevMode ? [{\n    debugName: \"debouncer\"\n  }] : []));\n  isNonInteractive = /*#__PURE__*/computed(() => this.hidden() || this.disabled() || this.readonly(), ...(ngDevMode ? [{\n    debugName: \"isNonInteractive\"\n  }] : []));\n}\nclass BasicFieldAdapter {\n  newRoot(fieldManager, value, pathNode, adapter) {\n    return new FieldNode({\n      kind: 'root',\n      fieldManager,\n      value,\n      pathNode,\n      logic: pathNode.builder.build(),\n      fieldAdapter: adapter\n    });\n  }\n  newChild(options) {\n    return new FieldNode(options);\n  }\n  createNodeState(node) {\n    return new FieldNodeState(node);\n  }\n  createValidationState(node) {\n    return new FieldValidationState(node);\n  }\n  createStructure(node, options) {\n    return node.createStructure(options);\n  }\n}\nclass FormFieldManager {\n  injector;\n  rootName;\n  constructor(injector, rootName) {\n    this.injector = injector;\n    this.rootName = rootName ?? `${this.injector.get(APP_ID)}.form${nextFormId++}`;\n  }\n  structures = /*#__PURE__*/new Set();\n  createFieldManagementEffect(root) {\n    effect(() => {\n      const liveStructures = new Set();\n      this.markStructuresLive(root, liveStructures);\n      for (const structure of this.structures) {\n        if (!liveStructures.has(structure)) {\n          this.structures.delete(structure);\n          untracked(() => structure.destroy());\n        }\n      }\n    }, {\n      injector: this.injector\n    });\n  }\n  markStructuresLive(structure, liveStructures) {\n    liveStructures.add(structure);\n    for (const child of structure.children()) {\n      this.markStructuresLive(child.structure, liveStructures);\n    }\n  }\n}\nlet nextFormId = 0;\nfunction normalizeFormArgs(args) {\n  let model;\n  let schema;\n  let options;\n  if (args.length === 3) {\n    [model, schema, options] = args;\n  } else if (args.length === 2) {\n    if (isSchemaOrSchemaFn(args[1])) {\n      [model, schema] = args;\n    } else {\n      [model, options] = args;\n    }\n  } else {\n    [model] = args;\n  }\n  return [model, schema, options];\n}\nfunction form(...args) {\n  const [model, schema, options] = normalizeFormArgs(args);\n  const injector = options?.injector ?? inject(Injector);\n  const pathNode = runInInjectionContext(injector, () => SchemaImpl.rootCompile(schema));\n  const fieldManager = new FormFieldManager(injector, options?.name);\n  const adapter = options?.adapter ?? new BasicFieldAdapter();\n  const fieldRoot = FieldNode.newRoot(fieldManager, model, pathNode, adapter);\n  fieldManager.createFieldManagementEffect(fieldRoot.structure);\n  return fieldRoot.fieldProxy;\n}\nfunction applyEach(path, schema) {\n  assertPathIsCurrent(path);\n  const elementPath = FieldPathNode.unwrapFieldPath(path).getChild(DYNAMIC).fieldPathProxy;\n  apply(elementPath, schema);\n}\nfunction apply(path, schema) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema));\n}\nfunction applyWhen(path, logic, schema) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.mergeIn(SchemaImpl.create(schema), {\n    fn: logic,\n    path\n  });\n}\nfunction applyWhenValue(path, predicate, schema) {\n  applyWhen(path, ({\n    value\n  }) => predicate(value()), schema);\n}\nasync function submit(form, action) {\n  const node = form();\n  markAllAsTouched(node);\n  if (node.invalid()) {\n    return;\n  }\n  node.submitState.selfSubmitting.set(true);\n  try {\n    const errors = await action(form);\n    errors && setServerErrors(node, errors);\n  } finally {\n    node.submitState.selfSubmitting.set(false);\n  }\n}\nfunction setServerErrors(submittedField, errors) {\n  if (!isArray(errors)) {\n    errors = [errors];\n  }\n  const errorsByField = new Map();\n  for (const error of errors) {\n    const errorWithField = addDefaultField(error, submittedField.fieldProxy);\n    const field = errorWithField.field();\n    let fieldErrors = errorsByField.get(field);\n    if (!fieldErrors) {\n      fieldErrors = [];\n      errorsByField.set(field, fieldErrors);\n    }\n    fieldErrors.push(errorWithField);\n  }\n  for (const [field, fieldErrors] of errorsByField) {\n    field.submitState.serverErrors.set(fieldErrors);\n  }\n}\nfunction schema(fn) {\n  return SchemaImpl.create(fn);\n}\nfunction markAllAsTouched(node) {\n  node.markAsTouched();\n  for (const child of node.structure.children()) {\n    markAllAsTouched(child);\n  }\n}\nexport { BasicFieldAdapter, DEBOUNCER, FieldNode, FieldNodeState, FieldNodeStructure, FieldPathNode, MAX, MAX_LENGTH, MIN, MIN_LENGTH, MetadataKey, MetadataReducer, PATTERN, REQUIRED, addDefaultField, apply, applyEach, applyWhen, applyWhenValue, assertPathIsCurrent, calculateValidationSelfStatus, createManagedMetadataKey, createMetadataKey, form, getInjectorFromOptions, isArray, metadata, normalizeFormArgs, schema, submit };\n","/**\n * @license Angular v21.0.5\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, Injector, input, computed, ɵCONTROL as _CONTROL, effect, Directive, ɵɵcontrolCreate as __controlCreate, ɵcontrolUpdate as _controlUpdate, ɵisPromise as _isPromise, resource } from '@angular/core';\nimport { Validators, NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';\nimport { assertPathIsCurrent, FieldPathNode, isArray, addDefaultField, metadata, createMetadataKey, MAX, MAX_LENGTH, MIN, MIN_LENGTH, PATTERN, REQUIRED, createManagedMetadataKey, DEBOUNCER } from './_structure-chunk.mjs';\nexport { MetadataKey, MetadataReducer, apply, applyEach, applyWhen, applyWhenValue, form, schema, submit } from './_structure-chunk.mjs';\nimport { httpResource } from '@angular/common/http';\nimport '@angular/core/primitives/signals';\nconst SIGNAL_FORMS_CONFIG = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'SIGNAL_FORMS_CONFIG' : '');\nfunction provideSignalFormsConfig(config) {\n  return [{\n    provide: SIGNAL_FORMS_CONFIG,\n    useValue: config\n  }];\n}\nclass InteropNgControl {\n  field;\n  constructor(field) {\n    this.field = field;\n  }\n  control = this;\n  get value() {\n    return this.field().value();\n  }\n  get valid() {\n    return this.field().valid();\n  }\n  get invalid() {\n    return this.field().invalid();\n  }\n  get pending() {\n    return this.field().pending();\n  }\n  get disabled() {\n    return this.field().disabled();\n  }\n  get enabled() {\n    return !this.field().disabled();\n  }\n  get errors() {\n    const errors = this.field().errors();\n    if (errors.length === 0) {\n      return null;\n    }\n    const errObj = {};\n    for (const error of errors) {\n      errObj[error.kind] = error;\n    }\n    return errObj;\n  }\n  get pristine() {\n    return !this.field().dirty();\n  }\n  get dirty() {\n    return this.field().dirty();\n  }\n  get touched() {\n    return this.field().touched();\n  }\n  get untouched() {\n    return !this.field().touched();\n  }\n  get status() {\n    if (this.field().disabled()) {\n      return 'DISABLED';\n    }\n    if (this.field().valid()) {\n      return 'VALID';\n    }\n    if (this.field().invalid()) {\n      return 'INVALID';\n    }\n    if (this.field().pending()) {\n      return 'PENDING';\n    }\n    throw Error('AssertionError: unknown form control status');\n  }\n  valueAccessor = null;\n  hasValidator(validator) {\n    if (validator === Validators.required) {\n      return this.field().required();\n    }\n    return false;\n  }\n  updateValueAndValidity() {}\n}\nconst FIELD = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'FIELD' : '');\nconst controlInstructions = {\n  create: __controlCreate,\n  update: _controlUpdate\n};\nlet Field = /*#__PURE__*/(() => {\n  class Field {\n    element = inject(ElementRef).nativeElement;\n    injector = inject(Injector);\n    field = input.required(...(ngDevMode ? [{\n      debugName: \"field\"\n    }] : []));\n    state = computed(() => this.field()(), ...(ngDevMode ? [{\n      debugName: \"state\"\n    }] : []));\n    [_CONTROL] = controlInstructions;\n    config = inject(SIGNAL_FORMS_CONFIG, {\n      optional: true\n    });\n    classes = Object.entries(this.config?.classes ?? {}).map(([className, computation]) => [className, computed(() => computation(this.state()))]);\n    controlValueAccessors = inject(NG_VALUE_ACCESSOR, {\n      optional: true,\n      self: true\n    });\n    interopNgControl;\n    get ɵinteropControl() {\n      return this.controlValueAccessors?.[0] ?? this.interopNgControl?.valueAccessor ?? undefined;\n    }\n    getOrCreateNgControl() {\n      return this.interopNgControl ??= new InteropNgControl(this.state);\n    }\n    ɵregister() {\n      effect(onCleanup => {\n        const fieldNode = this.state();\n        fieldNode.nodeState.fieldBindings.update(controls => [...controls, this]);\n        onCleanup(() => {\n          fieldNode.nodeState.fieldBindings.update(controls => controls.filter(c => c !== this));\n        });\n      }, {\n        injector: this.injector\n      });\n    }\n    static ɵfac = function Field_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Field)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: Field,\n      selectors: [[\"\", \"field\", \"\"]],\n      inputs: {\n        field: [1, \"field\"]\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: FIELD,\n        useExisting: Field\n      }, {\n        provide: NgControl,\n        useFactory: () => inject(Field).getOrCreateNgControl()\n      }])]\n    });\n  }\n  return Field;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction disabled(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addDisabledReasonRule(ctx => {\n    let result = true;\n    if (typeof logic === 'string') {\n      result = logic;\n    } else if (logic) {\n      result = logic(ctx);\n    }\n    if (typeof result === 'string') {\n      return {\n        field: ctx.field,\n        message: result\n      };\n    }\n    return result ? {\n      field: ctx.field\n    } : undefined;\n  });\n}\nfunction hidden(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addHiddenRule(logic);\n}\nfunction readonly(path, logic = () => true) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addReadonlyRule(logic);\n}\nfunction requiredError(options) {\n  return new RequiredValidationError(options);\n}\nfunction minError(min, options) {\n  return new MinValidationError(min, options);\n}\nfunction maxError(max, options) {\n  return new MaxValidationError(max, options);\n}\nfunction minLengthError(minLength, options) {\n  return new MinLengthValidationError(minLength, options);\n}\nfunction maxLengthError(maxLength, options) {\n  return new MaxLengthValidationError(maxLength, options);\n}\nfunction patternError(pattern, options) {\n  return new PatternValidationError(pattern, options);\n}\nfunction emailError(options) {\n  return new EmailValidationError(options);\n}\nfunction standardSchemaError(issue, options) {\n  return new StandardSchemaValidationError(issue, options);\n}\nfunction customError(obj) {\n  return new CustomValidationError(obj);\n}\nclass CustomValidationError {\n  __brand = undefined;\n  kind = '';\n  field;\n  message;\n  constructor(options) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\nclass _NgValidationError {\n  __brand = undefined;\n  kind = '';\n  field;\n  message;\n  constructor(options) {\n    if (options) {\n      Object.assign(this, options);\n    }\n  }\n}\nclass RequiredValidationError extends _NgValidationError {\n  kind = 'required';\n}\nclass MinValidationError extends _NgValidationError {\n  min;\n  kind = 'min';\n  constructor(min, options) {\n    super(options);\n    this.min = min;\n  }\n}\nclass MaxValidationError extends _NgValidationError {\n  max;\n  kind = 'max';\n  constructor(max, options) {\n    super(options);\n    this.max = max;\n  }\n}\nclass MinLengthValidationError extends _NgValidationError {\n  minLength;\n  kind = 'minLength';\n  constructor(minLength, options) {\n    super(options);\n    this.minLength = minLength;\n  }\n}\nclass MaxLengthValidationError extends _NgValidationError {\n  maxLength;\n  kind = 'maxLength';\n  constructor(maxLength, options) {\n    super(options);\n    this.maxLength = maxLength;\n  }\n}\nclass PatternValidationError extends _NgValidationError {\n  pattern;\n  kind = 'pattern';\n  constructor(pattern, options) {\n    super(options);\n    this.pattern = pattern;\n  }\n}\nclass EmailValidationError extends _NgValidationError {\n  kind = 'email';\n}\nclass StandardSchemaValidationError extends _NgValidationError {\n  issue;\n  kind = 'standardSchema';\n  constructor(issue, options) {\n    super(options);\n    this.issue = issue;\n  }\n}\nconst NgValidationError = _NgValidationError;\nfunction getLengthOrSize(value) {\n  const v = value;\n  return typeof v.length === 'number' ? v.length : v.size;\n}\nfunction getOption(opt, ctx) {\n  return opt instanceof Function ? opt(ctx) : opt;\n}\nfunction isEmpty(value) {\n  if (typeof value === 'number') {\n    return isNaN(value);\n  }\n  return value === '' || value === false || value == null;\n}\nfunction isPlainError(error) {\n  return typeof error === 'object' && (Object.getPrototypeOf(error) === Object.prototype || Object.getPrototypeOf(error) === null);\n}\nfunction ensureCustomValidationError(error) {\n  if (isPlainError(error)) {\n    return customError(error);\n  }\n  return error;\n}\nfunction ensureCustomValidationResult(result) {\n  if (result === null || result === undefined) {\n    return result;\n  }\n  if (isArray(result)) {\n    return result.map(ensureCustomValidationError);\n  }\n  return ensureCustomValidationError(result);\n}\nfunction validate(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncErrorRule(ctx => {\n    return ensureCustomValidationResult(addDefaultField(logic(ctx), ctx.field));\n  });\n}\nconst EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nfunction email(path, config) {\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    if (!EMAIL_REGEXP.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return emailError({\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction max(path, maxValue, config) {\n  const MAX_MEMO = metadata(path, createMetadataKey(), ctx => typeof maxValue === 'number' ? maxValue : maxValue(ctx));\n  metadata(path, MAX, ({\n    state\n  }) => state.metadata(MAX_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const max = ctx.state.metadata(MAX_MEMO)();\n    if (max === undefined || Number.isNaN(max)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value);\n    if (numValue > max) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxError(max, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction maxLength(path, maxLength, config) {\n  const MAX_LENGTH_MEMO = metadata(path, createMetadataKey(), ctx => typeof maxLength === 'number' ? maxLength : maxLength(ctx));\n  metadata(path, MAX_LENGTH, ({\n    state\n  }) => state.metadata(MAX_LENGTH_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const maxLength = ctx.state.metadata(MAX_LENGTH_MEMO)();\n    if (maxLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) > maxLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return maxLengthError(maxLength, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction min(path, minValue, config) {\n  const MIN_MEMO = metadata(path, createMetadataKey(), ctx => typeof minValue === 'number' ? minValue : minValue(ctx));\n  metadata(path, MIN, ({\n    state\n  }) => state.metadata(MIN_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const min = ctx.state.metadata(MIN_MEMO)();\n    if (min === undefined || Number.isNaN(min)) {\n      return undefined;\n    }\n    const value = ctx.value();\n    const numValue = !value && value !== 0 ? NaN : Number(value);\n    if (numValue < min) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minError(min, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction minLength(path, minLength, config) {\n  const MIN_LENGTH_MEMO = metadata(path, createMetadataKey(), ctx => typeof minLength === 'number' ? minLength : minLength(ctx));\n  metadata(path, MIN_LENGTH, ({\n    state\n  }) => state.metadata(MIN_LENGTH_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const minLength = ctx.state.metadata(MIN_LENGTH_MEMO)();\n    if (minLength === undefined) {\n      return undefined;\n    }\n    if (getLengthOrSize(ctx.value()) < minLength) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return minLengthError(minLength, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction pattern(path, pattern, config) {\n  const PATTERN_MEMO = metadata(path, createMetadataKey(), ctx => pattern instanceof RegExp ? pattern : pattern(ctx));\n  metadata(path, PATTERN, ({\n    state\n  }) => state.metadata(PATTERN_MEMO)());\n  validate(path, ctx => {\n    if (isEmpty(ctx.value())) {\n      return undefined;\n    }\n    const pattern = ctx.state.metadata(PATTERN_MEMO)();\n    if (pattern === undefined) {\n      return undefined;\n    }\n    if (!pattern.test(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return patternError(pattern, {\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction required(path, config) {\n  const REQUIRED_MEMO = metadata(path, createMetadataKey(), ctx => config?.when ? config.when(ctx) : true);\n  metadata(path, REQUIRED, ({\n    state\n  }) => state.metadata(REQUIRED_MEMO)());\n  validate(path, ctx => {\n    if (ctx.state.metadata(REQUIRED_MEMO)() && isEmpty(ctx.value())) {\n      if (config?.error) {\n        return getOption(config.error, ctx);\n      } else {\n        return requiredError({\n          message: getOption(config?.message, ctx)\n        });\n      }\n    }\n    return undefined;\n  });\n}\nfunction validateAsync(path, opts) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  const RESOURCE = createManagedMetadataKey(opts.factory);\n  metadata(path, RESOURCE, ctx => {\n    const node = ctx.stateOf(path);\n    const validationState = node.validationState;\n    if (validationState.shouldSkipValidation() || !validationState.syncValid()) {\n      return undefined;\n    }\n    return opts.params(ctx);\n  });\n  pathNode.builder.addAsyncErrorRule(ctx => {\n    const res = ctx.state.metadata(RESOURCE);\n    let errors;\n    switch (res.status()) {\n      case 'idle':\n        return undefined;\n      case 'loading':\n      case 'reloading':\n        return 'pending';\n      case 'resolved':\n      case 'local':\n        if (!res.hasValue()) {\n          return undefined;\n        }\n        errors = opts.onSuccess(res.value(), ctx);\n        return addDefaultField(errors, ctx.field);\n      case 'error':\n        errors = opts.onError(res.error(), ctx);\n        return addDefaultField(errors, ctx.field);\n    }\n  });\n}\nfunction validateTree(path, logic) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  pathNode.builder.addSyncTreeErrorRule(ctx => addDefaultField(logic(ctx), ctx.field));\n}\nfunction validateStandardSchema(path, schema) {\n  const VALIDATOR_MEMO = metadata(path, createMetadataKey(), ({\n    value\n  }) => {\n    return schema['~standard'].validate(value());\n  });\n  validateTree(path, ({\n    state,\n    fieldTreeOf\n  }) => {\n    const result = state.metadata(VALIDATOR_MEMO)();\n    if (_isPromise(result)) {\n      return [];\n    }\n    return result?.issues?.map(issue => standardIssueToFormTreeError(fieldTreeOf(path), issue)) ?? [];\n  });\n  validateAsync(path, {\n    params: ({\n      state\n    }) => {\n      const result = state.metadata(VALIDATOR_MEMO)();\n      return _isPromise(result) ? result : undefined;\n    },\n    factory: params => {\n      return resource({\n        params,\n        loader: async ({\n          params\n        }) => (await params)?.issues ?? []\n      });\n    },\n    onSuccess: (issues, {\n      fieldTreeOf\n    }) => {\n      return issues.map(issue => standardIssueToFormTreeError(fieldTreeOf(path), issue));\n    },\n    onError: () => {}\n  });\n}\nfunction standardIssueToFormTreeError(field, issue) {\n  let target = field;\n  for (const pathPart of issue.path ?? []) {\n    const pathKey = typeof pathPart === 'object' ? pathPart.key : pathPart;\n    target = target[pathKey];\n  }\n  return addDefaultField(standardSchemaError(issue, {\n    message: issue.message\n  }), target);\n}\nfunction validateHttp(path, opts) {\n  validateAsync(path, {\n    params: opts.request,\n    factory: request => httpResource(request, opts.options),\n    onSuccess: opts.onSuccess,\n    onError: opts.onError\n  });\n}\nfunction debounce(path, durationOrDebouncer) {\n  assertPathIsCurrent(path);\n  const pathNode = FieldPathNode.unwrapFieldPath(path);\n  const debouncer = typeof durationOrDebouncer === 'function' ? durationOrDebouncer : durationOrDebouncer > 0 ? debounceForDuration(durationOrDebouncer) : immediate;\n  pathNode.builder.addMetadataRule(DEBOUNCER, () => debouncer);\n}\nfunction debounceForDuration(durationInMilliseconds) {\n  return (_context, abortSignal) => {\n    return new Promise(resolve => {\n      const timeoutId = setTimeout(resolve, durationInMilliseconds);\n      abortSignal.addEventListener('abort', () => clearTimeout(timeoutId));\n    });\n  };\n}\nfunction immediate() {}\nexport { CustomValidationError, EmailValidationError, FIELD, Field, MAX, MAX_LENGTH, MIN, MIN_LENGTH, MaxLengthValidationError, MaxValidationError, MinLengthValidationError, MinValidationError, NgValidationError, PATTERN, PatternValidationError, REQUIRED, RequiredValidationError, StandardSchemaValidationError, createManagedMetadataKey, createMetadataKey, customError, debounce, disabled, email, emailError, hidden, max, maxError, maxLength, maxLengthError, metadata, min, minError, minLength, minLengthError, pattern, patternError, provideSignalFormsConfig, readonly, required, requiredError, standardSchemaError, validate, validateAsync, validateHttp, validateStandardSchema, validateTree };\n","export const validationMessages = {\n  required: 'To pole jest wymagane',\n  email: 'Nieprawidłowy format',\n};\n"],"mappings":"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","names":["boundPathDepth","getBoundPathDepth","setBoundPathDepthForResolution","fn","depth","args","shortCircuitFalse","value","shortCircuitTrue","isArray","value","isObject","DYNAMIC","IGNORED","AbstractLogic","predicates","logicFn","wrapWithPredicates","other","fns","fn","BooleanOrLogic","arg","f","result","ArrayMergeIgnoreLogic","_ArrayMergeIgnoreLogic","e","ignore","prev","ArrayMergeLogic","MetadataMergeLogic","key","ctx","acc","i","item","predicate","predicateField","depthDiff","untracked","LogicContainer","metadataLogic","AbstractLogicNodeBuilder","depth","LeafLogicNode","LogicNodeBuilder","_LogicNodeBuilder","logic","children","builder","subBuilder","setBoundPathDepthForResolution","NonMergeableLogicNodeBuilder","_LeafLogicNode","createLogic","childBuilders","getAllChildBuilders","p","bindLevel","builtNodes","CompositeLogicNode","_CompositeLogicNode","all","node","child","__spreadProps","__spreadValues","PATH","FieldPathNode","_FieldPathNode","FIELD_PATH_PROXY_HANDLER","keys","root","parent","keyInParent","path","formPath","property","currentCompilingNode","compiledSchemas","SchemaImpl","_SchemaImpl","schemaFn","prevCompilingNode","schema","isSchemaOrSchemaFn","assertPathIsCurrent","metadata","MetadataReducer","next","override","getInitial","_","MetadataKey","reducer","create","createMetadataKey","REQUIRED","createMetadataKey","MetadataReducer","MIN","MAX","MIN_LENGTH","MAX_LENGTH","PATTERN","calculateValidationSelfStatus","state","FieldValidationState","node","computed","normalizeErrors","child","value","shortCircuitFalse","err","result","ownStatus","v","error","isArray","addDefaultField","errors","field","DEBOUNCER","FieldNodeContext","target","resolver","targetPathNode","FieldPathNode","stepsRemaining","getBoundPathDepth","key","untracked","p","AbstractControl","FieldMetadataState","logic","runInInjectionContext","FIELD_PROXY_HANDLER","getTgt","receiver","tgt","isObject","prop","desc","deepSignal","source","read","SIGNAL","current","valueForWrite","fn","sourceValue","newPropValue","newValue","__spreadProps","__spreadValues","FieldNodeStructure","Injector","createChildNode","map","strKey","reader","initialValue","shortCircuit","options","identityInParent","initialKeyInParent","ROOT_KEY_IN_PARENT","getDebugName","lastKnownKey","parentValue","data","i","linkedSignal","previous","prevData","parentIsArray","maybeRemoveStaleArrayFields","maybeRemoveStaleObjectFields","trackingKey","childValue","childNode","RootFieldNodeStructure","ROOT_PATH_KEYS","fieldManager","ChildFieldNodeStructure","parent","ROOT_PATH_KEYS","computed","ROOT_KEY_IN_PARENT","getDebugName","node","maybeRemoveStaleArrayFields","prevData","value","identitySymbol","data","oldKeys","oldTracking","i","childValue","isObject","__spreadValues","key","id","maybeRemoveStaleObjectFields","FieldSubmitState","signal","linkedSignal","FieldNode","FieldNodeContext","FIELD_PROXY_HANDLER","options","FieldMetadataState","_source","previous","MAX","MAX_LENGTH","MIN","MIN_LENGTH","PATTERN","EMPTY","REQUIRED","FALSE","untracked","child","newValue","debouncer","controller","promise","fieldManager","pathNode","adapter","RootFieldNodeStructure","ChildFieldNodeStructure","trackingId","isArray","childPath","childLogic","DYNAMIC","FieldNodeState","selfDirtyValue","shortCircuitTrue","selfTouchedValue","parent","DEBOUNCER","BasicFieldAdapter","FieldValidationState","FormFieldManager","injector","rootName","APP_ID","nextFormId","root","effect","liveStructures","structure","normalizeFormArgs","args","model","schema","isSchemaOrSchemaFn","form","inject","Injector","runInInjectionContext","SchemaImpl","fieldRoot","submit","form","action","node","markAllAsTouched","errors","setServerErrors","submittedField","isArray","errorsByField","error","errorWithField","addDefaultField","field","fieldErrors","markAllAsTouched","node","child","SIGNAL_FORMS_CONFIG","InjectionToken","InteropNgControl","field","errors","errObj","error","validator","Validators","FIELD","InjectionToken","controlInstructions","ɵɵcontrolCreate","ɵcontrolUpdate","Field","inject","ElementRef","Injector","input","computed","ɵCONTROL","SIGNAL_FORMS_CONFIG","className","computation","NG_VALUE_ACCESSOR","effect","onCleanup","fieldNode","controls","c","__ngFactoryType__","ɵɵdefineDirective","ɵɵProvidersFeature","NgControl","hidden","path","logic","assertPathIsCurrent","FieldPathNode","requiredError","options","RequiredValidationError","minLengthError","minLength","options","MinLengthValidationError","emailError","options","EmailValidationError","customError","obj","CustomValidationError","options","_NgValidationError","RequiredValidationError","MinLengthValidationError","_NgValidationError","minLength","options","EmailValidationError","_NgValidationError","getLengthOrSize","value","v","getOption","opt","ctx","isEmpty","isPlainError","error","ensureCustomValidationError","customError","ensureCustomValidationResult","result","isArray","validate","path","logic","assertPathIsCurrent","FieldPathNode","addDefaultField","EMAIL_REGEXP","email","config","emailError","minLength","path","config","MIN_LENGTH_MEMO","metadata","createMetadataKey","ctx","MIN_LENGTH","state","validate","isEmpty","getLengthOrSize","getOption","minLengthError","required","path","config","REQUIRED_MEMO","metadata","createMetadataKey","ctx","REQUIRED","state","validate","isEmpty","getOption","requiredError","validationMessages","required","email"],"x_google_ignoreList":[0,1]}